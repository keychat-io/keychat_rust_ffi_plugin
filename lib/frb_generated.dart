// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api_cashu.dart';
import 'api_cashu/types.dart';
import 'api_cashu_v1.dart';
import 'api_mls.dart';
import 'api_mls/types.dart';
import 'api_nostr.dart';
import 'api_signal.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart' if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';


                /// Main entrypoint of the Rust API
                class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
                  @internal
                  static final instance = RustLib._();

                  RustLib._();

                  /// Initialize flutter_rust_bridge
                  static Future<void> init({
                    RustLibApi? api,
                    BaseHandler? handler,
                    ExternalLibrary? externalLibrary,
                  }) async {
                    await instance.initImpl(
                      api: api,
                      handler: handler,
                      externalLibrary: externalLibrary,
                    );
                  }

                  /// Initialize flutter_rust_bridge in mock mode.
                  /// No libraries for FFI are loaded.
                  static void initMock({
                    required RustLibApi api,
                  }) {
                    instance.initMockImpl(
                      api: api,
                    );
                  }

                  /// Dispose flutter_rust_bridge
                  ///
                  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
                  /// is automatically disposed when the app stops.
                  static void dispose() => instance.disposeImpl();

                  @override
                  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor => RustLibApiImpl.new;

                  @override
                  WireConstructor<RustLibWire> get wireConstructor => RustLibWire.fromExternalLibrary;

                  @override
                  Future<void> executeRustInitializers() async {
                    
                  }

                  @override
                  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig => kDefaultExternalLibraryLoaderConfig;

                  @override
                  String get codegenVersion => '2.10.0';

                  @override
                  int get rustContentHash => -224612865;

                  static const kDefaultExternalLibraryLoaderConfig = ExternalLibraryLoaderConfig(
                    stem: 'keychat_rust_ffi_plugin',
                    ioDirectory: 'rust/target/release/',
                    webPrefix: 'pkg/',
                  );
                }
                

                abstract class RustLibApi extends BaseApi {
                  Future<String> crateApiCashuTypesMnemonicInfoGenerateWords({required BigInt words });

Future<void> crateApiCashuTypesMnemonicInfoMnemonic({required MnemonicInfo that });

Future<MnemonicInfo> crateApiCashuTypesMnemonicInfoNew({required Mnemonic mnemonic });

Future<void> crateApiCashuTypesMnemonicInfoPubkey({required MnemonicInfo that });

Future<MnemonicInfo> crateApiCashuTypesMnemonicInfoWithWords({required String words });

Future<void> crateApiCashuAddCounters({required String counters });

Future<AddMembersResult> crateApiMlsAddMembers({required String nostrId , required String groupId , required List<String> keyPackages });

Future<void> crateApiCashuAddMint({required String url });

Future<void> crateApiMlsAdminCommitLeave({required String nostrId , required String groupId });

Future<Uint8List> crateApiMlsAdminProposalLeave({required String nostrId , required String groupId });

Future<CashuV1ToV2> crateApiCashuCashuV1InitSendAll({required String dbpath , String? words });

Future<(List<String>,String,Set<String>)> crateApiCashuV1CashuV1InitSendAll({required String dbpath , String? words });

Future<BigInt> crateApiCashuCheckAllMintQuotes();

Future<void> crateApiCashuCheckPending();

Future<void> crateApiCashuCheckProofs();

Future<Transaction> crateApiCashuCheckTransaction({required String id });

Future<ContactCashu> crateApiCashuTypesContactCashuDefault();

Future<bool> crateApiSignalContainsSession({required KeychatIdentityKeyPair keyPair , required KeychatProtocolAddress address });

Future<String> crateApiNostrCreateGiftJson({required int kind , required String senderKeys , required String receiverPubkey , required String content , BigInt? expirationTimestamp , bool? timestampTweaked , List<List<String>>? additionalTags });

Future<Uint8List> crateApiMlsCreateGroupConfig();

Future<KeyPackageResult> crateApiMlsCreateKeyPackage({required String nostrId });

Future<MessageResult> crateApiMlsCreateMessage({required String nostrId , required String groupId , required String msg });

Future<Uint8List> crateApiMlsCreateMlsGroup({required String nostrId , required String groupId , required String groupName , required String description , required List<String> adminPubkeysHex , required List<String> groupRelays , required String status });

Future<String> crateApiNostrCurve25519GetPubkey({required String prikey });

Future<String> crateApiNostrCurve25519Sign({required List<int> secretKey , required List<int> message });

Future<bool> crateApiNostrCurve25519Verify({required List<int> publicKey , required List<int> message , required String sig });

String crateApiNostrDecodeBech32({required String content });

Future<InvoiceInfo> crateApiCashuDecodeInvoice({required String encodedInvoice });

Future<TokenInfo> crateApiCashuDecodeToken({required String encodedToken });

Future<String> crateApiNostrDecrypt({required String senderKeys , required String receiverPubkey , required String content });

Future<String> crateApiNostrDecryptEvent({required String senderKeys , required String json });

Future<NostrEvent> crateApiNostrDecryptGift({required String senderKeys , required String receiver , required String content });

Future<DecryptedMessage> crateApiMlsDecryptMessage({required String nostrId , required String groupId , required String msg });

Future<String> crateApiNostrDecryptNip44({required String secretKey , required String publicKey , required String content });

Future<(Uint8List,String,List<String>?)> crateApiSignalDecryptSignal({required KeychatIdentityKeyPair keyPair , required List<int> ciphertext , required KeychatProtocolAddress remoteAddress , required int roomId , required bool isPrekey });

Future<void> crateApiMlsDeleteGroup({required String nostrId , required String groupId });

Future<bool> crateApiSignalDeleteIdentity({required KeychatIdentityKeyPair keyPair , required String address });

Future<void> crateApiMlsDeleteKeyPackage({required String nostrId , required String keyPackage });

Future<bool> crateApiSignalDeleteSession({required KeychatIdentityKeyPair keyPair , required KeychatProtocolAddress address });

Future<bool> crateApiSignalDeleteSessionByDeviceId({required KeychatIdentityKeyPair keyPair , required int deviceId });

String crateApiNostrEncodeBech32({required String hrp , required String data });

Future<String> crateApiNostrEncrypt({required String senderKeys , required String receiverPubkey , required String content });

Future<String> crateApiNostrEncryptNip44({required String senderKeys , required String receiverPubkey , required String content });

Future<(Uint8List,String?,String,List<String>?)> crateApiSignalEncryptSignal({required KeychatIdentityKeyPair keyPair , required String ptext , required KeychatProtocolAddress remoteAddress , bool? isPrekey });

Future<(Uint8List,Uint8List)> crateApiNostrGenerateCurve25519Keypair({required String mnemonicWords , String? password , int? pos });

Future<Secp256k1Account> crateApiNostrGenerateFromMnemonic({String? password });

Future<String> crateApiNostrGenerateMessageKeyHash({required String seedKey });

Future<(int,Uint8List,Uint8List)> crateApiSignalGeneratePrekeyApi({required KeychatIdentityKeyPair keyPair });

Future<Secp256k1Account> crateApiNostrGenerateSecp256K1();

Future<String> crateApiNostrGenerateSeedFromKey({required List<int> seedKey });

Future<String> crateApiNostrGenerateSeedFromRatchetkeyPair({required String seedKey });

Future<(Uint8List,Uint8List)> crateApiSignalGenerateSignalIds();

Future<(int,Uint8List,Uint8List,Uint8List)> crateApiSignalGenerateSignedKeyApi({required KeychatIdentityKeyPair keyPair , required List<int> signalIdentityPrivateKey });

Future<Secp256k1SimpleAccount> crateApiNostrGenerateSimple();

Future<List<String>> crateApiSignalGetAllAliceAddrs({required KeychatIdentityKeyPair keyPair });

Future<(BigInt,BigInt,BigInt)> crateApiCashuGetAllProofsData();

Future<List<Transaction>> crateApiCashuGetAllTransactions();

Future<String> crateApiCashuGetBalances();

String crateApiNostrGetBech32PrikeyByHex({required String hex });

String crateApiNostrGetBech32PubkeyByHex({required String hex });

Future<List<Transaction>> crateApiCashuGetCashuPendingTransactions();

Future<List<Transaction>> crateApiCashuGetCashuTransactionsWithOffset({required BigInt offset , required BigInt limit });

Future<String> crateApiNostrGetEncryptEvent({required String senderKeys , required String receiverPubkey , required String content , String? reply });

Future<Uint8List> crateApiMlsGetGroupConfig({required String nostrId , required String groupId });

Future<GroupExtensionResult> crateApiMlsGetGroupExtension({required String nostrId , required String groupId });

Future<List<String>> crateApiMlsGetGroupMembers({required String nostrId , required String groupId });

Future<Map<String, BigInt?>> crateApiMlsGetGroupMembersWithLifetime({required String nostrId , required String groupId });

String crateApiNostrGetHexPrikeyByBech32({required String bech32 });

String crateApiNostrGetHexPubkeyByBech32({required String bech32 });

String crateApiNostrGetHexPubkeyByPrikey({required String prikey });

Future<KeychatIdentityKey?> crateApiSignalGetIdentity({required KeychatIdentityKeyPair keyPair , required KeychatProtocolAddress address });

Future<Uint8List> crateApiMlsGetLeadNodeIndex({required String nostrIdAdmin , required String nostrIdCommon , required String groupId });

Future<String> crateApiMlsGetListenKeyFromExportSecret({required String nostrId , required String groupId });

Future<List<Transaction>> crateApiCashuGetLnPendingTransactions();

Future<List<Transaction>> crateApiCashuGetLnTransactionsWithOffset({required BigInt offset , required BigInt limit });

Future<Map<String, List<Uint8List>>> crateApiMlsGetMemberExtension({required String nostrId , required String groupId });

Future<List<MintCashu>> crateApiCashuGetMints();

Future<BigInt> crateApiCashuGetPendingTransactionsCount();

Future<Uint8List> crateApiSignalGetPrekeyApi({required KeychatIdentityKeyPair keyPair , required int prekeyId });

Future<String?> crateApiMlsGetSender({required String nostrId , required String groupId , required String queuedMsg });

Future<KeychatSignalSession?> crateApiSignalGetSession({required KeychatIdentityKeyPair keyPair , required String address , required String deviceId });

Future<Uint8List> crateApiSignalGetSignedKeyApi({required KeychatIdentityKeyPair keyPair , required int signedKeyId });

Future<Uint8List> crateApiMlsGetTreeHash({required String nostrId , required String groupId });

Future<String> crateApiNostrGetUnencryptEvent({required String senderKeys , required List<String> receiverPubkeys , required String content , required int kind , List<List<String>>? additionalTags });

Future<Wallet> crateApiCashuGetWalletByIndex({required MultiMintWallet multiMintWallet , required List<(MintUrl,Amount)> mintAmounts , required BigInt mintNumber , required CurrencyUnit unit });

Future<Secp256k1Account> crateApiNostrImportFromPhrase({required String phrase , String? password , int? account });

Future<List<Secp256k1Account>> crateApiNostrImportFromPhraseWith({required String phrase , String? password , required int offset , required int count });

Future<Secp256k1Account> crateApiNostrImportKey({required String senderKeys });

Future<void> crateApiSignalInit({required String dbPath , required KeychatIdentityKeyPair keyPair , required int regId });

Future<List<MintCashu>> crateApiCashuInitCashu({required int prepareSatsOnceTime });

Future<void> crateApiCashuInitDb({required String dbpath , required String words , required bool dev });

Future<void> crateApiCashuInitDbCashuOnce({required String dbpath });

Future<void> crateApiSignalInitKeypair({required KeychatIdentityKeyPair keyPair , required int regId });

Future<void> crateApiMlsInitMlsDb({required String dbPath , required String nostrId });

Future<void> crateApiSignalInitSignalDb({required String dbPath });

Future<void> crateApiMlsJoinMlsGroup({required String nostrId , required String groupId , required List<int> welcome });

Future<Transaction> crateApiCashuMelt({required String invoice , required String activeMint , BigInt? amount });

Future<void> crateApiCashuMergeProofs({required BigInt thershold });

Future<MintCashuInfo> crateApiCashuTypesMintCashuInfoDefault();

Future<Transaction> crateApiCashuMintToken({required BigInt amount , required String quoteId , required String activeMint });

Future<void> crateApiCashuMultiReceive({required List<String> stamps });

Future<String> crateApiNostrNip47EncodeUri({required String pubkey , required String relay , required String secret , String? lud16 });

Future<String> crateApiNostrNip47ParseRequest({required String request });

Future<void> crateApiMlsNormalMemberCommitLeave({required String nostrId , required String groupId , required List<int> queuedMsg });

Future<CommitResult> crateApiMlsOthersCommitNormal({required String nostrId , required String groupId , required String queuedMsg });

Future<void> crateApiMlsOthersProposalLeave({required String nostrId , required String groupId , required List<int> queuedMsg });

Future<(String,int)> crateApiSignalParseIdentityFromPrekeySignalMessage({required List<int> ciphertext });

Future<bool> crateApiSignalParseIsPrekeySignalMessage({required List<int> ciphertext });

Future<BigInt> crateApiMlsParseLifetimeFromKeyPackage({required String nostrId , required String keyPackageHex });

Future<MessageInType> crateApiMlsParseMlsMsgType({required String nostrId , required String groupId , required String data });

Future<BigInt> crateApiCashuPrepareOneProofs({required BigInt amount , required String mint });

Future<void> crateApiCashuPrintProofs({required String mint });

Future<void> crateApiSignalProcessPrekeyBundleApi({required KeychatIdentityKeyPair keyPair , required KeychatProtocolAddress remoteAddress , required int regId , required int deviceId , required KeychatIdentityKey identityKey , required int bobSignedId , required List<int> bobSignedPublic , required List<int> bobSigedSig , required int bobPrekeyId , required List<int> bobPrekeyPublic });

Future<Transaction> crateApiCashuReceiveToken({required String encodedToken });

Future<String> crateApiMlsRemoveMembers({required String nostrId , required String groupId , required List<Uint8List> members });

Future<void> crateApiCashuRemoveMint({required String url });

Future<void> crateApiCashuRemoveTransactions({required BigInt unixTimestampLe , required TransactionStatus status });

Future<Transaction> crateApiCashuRequestMint({required BigInt amount , required String activeMint });

Future<(BigInt,BigInt)> crateApiCashuRestore({required String mintUrl , String? words });

Future<void> crateApiMlsSelfCommit({required String nostrId , required String groupId });

Future<Uint8List> crateApiMlsSelfLeave({required String nostrId , required String groupId });

Future<String> crateApiMlsSelfUpdate({required String nostrId , required String groupId , required List<int> extensions });

Future<Transaction> crateApiCashuSend({required BigInt amount , required String activeMint , String? info });

Future<Transaction> crateApiCashuSendAll({required String mint });

Future<Transaction> crateApiCashuSendStamp({required BigInt amount , required List<String> mints , String? info });

Future<KeychatSignalSession?> crateApiSignalSessionContainAliceAddr({required KeychatIdentityKeyPair keyPair , required String address });

Future<bool> crateApiCashuSetMnemonic({String? words });

Future<String> crateApiNostrSha1Hash({required String data });

Future<String> crateApiNostrSha256Hash({required String data });

Future<String> crateApiNostrSha256HashBytes({required List<int> data });

Future<String> crateApiNostrSignEvent({required String senderKeys , required String content , required BigInt createdAt , required int kind , required List<List<String>> tags });

Future<String> crateApiNostrSignSchnorr({required String privateKey , required String content });

Future<void> crateApiSignalStorePrekeyApi({required KeychatIdentityKeyPair keyPair , required int prekeyId , required List<int> record });

Future<void> crateApiSignalStoreSignedKeyApi({required KeychatIdentityKeyPair keyPair , required int signedKeyId , required List<int> record });

Future<(List<String>,Set<String>)> crateApiCashuV1TryUnreachableMints({required String dbpath , String? words , required List<String> mints });

Future<bool> crateApiSignalUpdateAliceAddr({required KeychatIdentityKeyPair keyPair , required String address , required String deviceId , required String aliceAddr });

Future<String> crateApiMlsUpdateGroupContextExtensions({required String nostrId , required String groupId , String? groupName , String? description , List<String>? adminPubkeysHex , List<String>? groupRelays , String? status });

Future<void> crateApiCashuValidateMintNumber({required BigInt mintNumber , required BigInt mintCount });

Future<NostrEvent> crateApiNostrVerifyEvent({required String json });

Future<bool> crateApiNostrVerifySchnorr({required String pubkey , required String sig , required String content , required bool hash });

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Amount;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Amount;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_AmountPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_CurrencyUnit;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_CurrencyUnit;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_CurrencyUnitPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_MintUrl;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_MintUrl;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MintUrlPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Mnemonic;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Mnemonic;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MnemonicPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_MnemonicInfo;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_MnemonicInfo;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MnemonicInfoPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_MultiMintWallet;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_MultiMintWallet;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MultiMintWalletPtr;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Wallet;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Wallet;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WalletPtr;


                }
                

                class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
                  RustLibApiImpl({
                    required super.handler,
                    required super.wire,
                    required super.generalizedFrbRustBinding,
                    required super.portManager,
                  });

                  @override Future<String> crateApiCashuTypesMnemonicInfoGenerateWords({required BigInt words })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_usize(words, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuTypesMnemonicInfoGenerateWordsConstMeta,
            argValues: [words],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuTypesMnemonicInfoGenerateWordsConstMeta => const TaskConstMeta(
            debugName: "MnemonicInfo_generate_words",
            argNames: ["words"],
        );
        

@override Future<void> crateApiCashuTypesMnemonicInfoMnemonic({required MnemonicInfo that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonicInfo(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiCashuTypesMnemonicInfoMnemonicConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuTypesMnemonicInfoMnemonicConstMeta => const TaskConstMeta(
            debugName: "MnemonicInfo_mnemonic",
            argNames: ["that"],
        );
        

@override Future<MnemonicInfo> crateApiCashuTypesMnemonicInfoNew({required Mnemonic mnemonic })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(mnemonic, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonicInfo,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuTypesMnemonicInfoNewConstMeta,
            argValues: [mnemonic],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuTypesMnemonicInfoNewConstMeta => const TaskConstMeta(
            debugName: "MnemonicInfo_new",
            argNames: ["mnemonic"],
        );
        

@override Future<void> crateApiCashuTypesMnemonicInfoPubkey({required MnemonicInfo that })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonicInfo(that, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiCashuTypesMnemonicInfoPubkeyConstMeta,
            argValues: [that],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuTypesMnemonicInfoPubkeyConstMeta => const TaskConstMeta(
            debugName: "MnemonicInfo_pubkey",
            argNames: ["that"],
        );
        

@override Future<MnemonicInfo> crateApiCashuTypesMnemonicInfoWithWords({required String words })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(words, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonicInfo,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuTypesMnemonicInfoWithWordsConstMeta,
            argValues: [words],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuTypesMnemonicInfoWithWordsConstMeta => const TaskConstMeta(
            debugName: "MnemonicInfo_with_words",
            argNames: ["words"],
        );
        

@override Future<void> crateApiCashuAddCounters({required String counters })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(counters, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuAddCountersConstMeta,
            argValues: [counters],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuAddCountersConstMeta => const TaskConstMeta(
            debugName: "add_counters",
            argNames: ["counters"],
        );
        

@override Future<AddMembersResult> crateApiMlsAddMembers({required String nostrId , required String groupId , required List<String> keyPackages })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
sse_encode_list_String(keyPackages, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 7, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_add_members_result,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsAddMembersConstMeta,
            argValues: [nostrId, groupId, keyPackages],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsAddMembersConstMeta => const TaskConstMeta(
            debugName: "add_members",
            argNames: ["nostrId", "groupId", "keyPackages"],
        );
        

@override Future<void> crateApiCashuAddMint({required String url })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(url, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 8, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuAddMintConstMeta,
            argValues: [url],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuAddMintConstMeta => const TaskConstMeta(
            debugName: "add_mint",
            argNames: ["url"],
        );
        

@override Future<void> crateApiMlsAdminCommitLeave({required String nostrId , required String groupId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsAdminCommitLeaveConstMeta,
            argValues: [nostrId, groupId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsAdminCommitLeaveConstMeta => const TaskConstMeta(
            debugName: "admin_commit_leave",
            argNames: ["nostrId", "groupId"],
        );
        

@override Future<Uint8List> crateApiMlsAdminProposalLeave({required String nostrId , required String groupId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 10, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsAdminProposalLeaveConstMeta,
            argValues: [nostrId, groupId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsAdminProposalLeaveConstMeta => const TaskConstMeta(
            debugName: "admin_proposal_leave",
            argNames: ["nostrId", "groupId"],
        );
        

@override Future<CashuV1ToV2> crateApiCashuCashuV1InitSendAll({required String dbpath , String? words })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dbpath, serializer);
sse_encode_opt_String(words, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 11, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_cashu_v_1_to_v_2,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuCashuV1InitSendAllConstMeta,
            argValues: [dbpath, words],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuCashuV1InitSendAllConstMeta => const TaskConstMeta(
            debugName: "cashu_v1_init_send_all",
            argNames: ["dbpath", "words"],
        );
        

@override Future<(List<String>,String,Set<String>)> crateApiCashuV1CashuV1InitSendAll({required String dbpath , String? words })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dbpath, serializer);
sse_encode_opt_String(words, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 12, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_list_string_string_set_string_none,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuV1CashuV1InitSendAllConstMeta,
            argValues: [dbpath, words],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuV1CashuV1InitSendAllConstMeta => const TaskConstMeta(
            debugName: "cashu_v1_init_send_all",
            argNames: ["dbpath", "words"],
        );
        

@override Future<BigInt> crateApiCashuCheckAllMintQuotes()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 13, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuCheckAllMintQuotesConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuCheckAllMintQuotesConstMeta => const TaskConstMeta(
            debugName: "check_all_mint_quotes",
            argNames: [],
        );
        

@override Future<void> crateApiCashuCheckPending()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 14, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuCheckPendingConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuCheckPendingConstMeta => const TaskConstMeta(
            debugName: "check_pending",
            argNames: [],
        );
        

@override Future<void> crateApiCashuCheckProofs()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuCheckProofsConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuCheckProofsConstMeta => const TaskConstMeta(
            debugName: "check_proofs",
            argNames: [],
        );
        

@override Future<Transaction> crateApiCashuCheckTransaction({required String id })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(id, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 16, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuCheckTransactionConstMeta,
            argValues: [id],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuCheckTransactionConstMeta => const TaskConstMeta(
            debugName: "check_transaction",
            argNames: ["id"],
        );
        

@override Future<ContactCashu> crateApiCashuTypesContactCashuDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_contact_cashu,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiCashuTypesContactCashuDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuTypesContactCashuDefaultConstMeta => const TaskConstMeta(
            debugName: "contact_cashu_default",
            argNames: [],
        );
        

@override Future<bool> crateApiSignalContainsSession({required KeychatIdentityKeyPair keyPair , required KeychatProtocolAddress address })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_box_autoadd_keychat_protocol_address(address, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 18, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalContainsSessionConstMeta,
            argValues: [keyPair, address],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalContainsSessionConstMeta => const TaskConstMeta(
            debugName: "contains_session",
            argNames: ["keyPair", "address"],
        );
        

@override Future<String> crateApiNostrCreateGiftJson({required int kind , required String senderKeys , required String receiverPubkey , required String content , BigInt? expirationTimestamp , bool? timestampTweaked , List<List<String>>? additionalTags })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_16(kind, serializer);
sse_encode_String(senderKeys, serializer);
sse_encode_String(receiverPubkey, serializer);
sse_encode_String(content, serializer);
sse_encode_opt_box_autoadd_u_64(expirationTimestamp, serializer);
sse_encode_opt_box_autoadd_bool(timestampTweaked, serializer);
sse_encode_opt_list_list_String(additionalTags, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrCreateGiftJsonConstMeta,
            argValues: [kind, senderKeys, receiverPubkey, content, expirationTimestamp, timestampTweaked, additionalTags],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrCreateGiftJsonConstMeta => const TaskConstMeta(
            debugName: "create_gift_json",
            argNames: ["kind", "senderKeys", "receiverPubkey", "content", "expirationTimestamp", "timestampTweaked", "additionalTags"],
        );
        

@override Future<Uint8List> crateApiMlsCreateGroupConfig()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 20, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsCreateGroupConfigConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsCreateGroupConfigConstMeta => const TaskConstMeta(
            debugName: "create_group_config",
            argNames: [],
        );
        

@override Future<KeyPackageResult> crateApiMlsCreateKeyPackage({required String nostrId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 21, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_key_package_result,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsCreateKeyPackageConstMeta,
            argValues: [nostrId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsCreateKeyPackageConstMeta => const TaskConstMeta(
            debugName: "create_key_package",
            argNames: ["nostrId"],
        );
        

@override Future<MessageResult> crateApiMlsCreateMessage({required String nostrId , required String groupId , required String msg })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
sse_encode_String(msg, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 22, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_message_result,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsCreateMessageConstMeta,
            argValues: [nostrId, groupId, msg],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsCreateMessageConstMeta => const TaskConstMeta(
            debugName: "create_message",
            argNames: ["nostrId", "groupId", "msg"],
        );
        

@override Future<Uint8List> crateApiMlsCreateMlsGroup({required String nostrId , required String groupId , required String groupName , required String description , required List<String> adminPubkeysHex , required List<String> groupRelays , required String status })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
sse_encode_String(groupName, serializer);
sse_encode_String(description, serializer);
sse_encode_list_String(adminPubkeysHex, serializer);
sse_encode_list_String(groupRelays, serializer);
sse_encode_String(status, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 23, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsCreateMlsGroupConstMeta,
            argValues: [nostrId, groupId, groupName, description, adminPubkeysHex, groupRelays, status],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsCreateMlsGroupConstMeta => const TaskConstMeta(
            debugName: "create_mls_group",
            argNames: ["nostrId", "groupId", "groupName", "description", "adminPubkeysHex", "groupRelays", "status"],
        );
        

@override Future<String> crateApiNostrCurve25519GetPubkey({required String prikey })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(prikey, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 24, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrCurve25519GetPubkeyConstMeta,
            argValues: [prikey],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrCurve25519GetPubkeyConstMeta => const TaskConstMeta(
            debugName: "curve25519_get_pubkey",
            argNames: ["prikey"],
        );
        

@override Future<String> crateApiNostrCurve25519Sign({required List<int> secretKey , required List<int> message })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_list_prim_u_8_loose(secretKey, serializer);
sse_encode_list_prim_u_8_loose(message, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrCurve25519SignConstMeta,
            argValues: [secretKey, message],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrCurve25519SignConstMeta => const TaskConstMeta(
            debugName: "curve25519_sign",
            argNames: ["secretKey", "message"],
        );
        

@override Future<bool> crateApiNostrCurve25519Verify({required List<int> publicKey , required List<int> message , required String sig })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_list_prim_u_8_loose(publicKey, serializer);
sse_encode_list_prim_u_8_loose(message, serializer);
sse_encode_String(sig, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 26, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrCurve25519VerifyConstMeta,
            argValues: [publicKey, message, sig],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrCurve25519VerifyConstMeta => const TaskConstMeta(
            debugName: "curve25519_verify",
            argNames: ["publicKey", "message", "sig"],
        );
        

@override String crateApiNostrDecodeBech32({required String content })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(content, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 27)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrDecodeBech32ConstMeta,
            argValues: [content],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrDecodeBech32ConstMeta => const TaskConstMeta(
            debugName: "decode_bech32",
            argNames: ["content"],
        );
        

@override Future<InvoiceInfo> crateApiCashuDecodeInvoice({required String encodedInvoice })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(encodedInvoice, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 28, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_invoice_info,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuDecodeInvoiceConstMeta,
            argValues: [encodedInvoice],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuDecodeInvoiceConstMeta => const TaskConstMeta(
            debugName: "decode_invoice",
            argNames: ["encodedInvoice"],
        );
        

@override Future<TokenInfo> crateApiCashuDecodeToken({required String encodedToken })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(encodedToken, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 29, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_token_info,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuDecodeTokenConstMeta,
            argValues: [encodedToken],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuDecodeTokenConstMeta => const TaskConstMeta(
            debugName: "decode_token",
            argNames: ["encodedToken"],
        );
        

@override Future<String> crateApiNostrDecrypt({required String senderKeys , required String receiverPubkey , required String content })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(senderKeys, serializer);
sse_encode_String(receiverPubkey, serializer);
sse_encode_String(content, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 30, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrDecryptConstMeta,
            argValues: [senderKeys, receiverPubkey, content],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrDecryptConstMeta => const TaskConstMeta(
            debugName: "decrypt",
            argNames: ["senderKeys", "receiverPubkey", "content"],
        );
        

@override Future<String> crateApiNostrDecryptEvent({required String senderKeys , required String json })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(senderKeys, serializer);
sse_encode_String(json, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 31, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrDecryptEventConstMeta,
            argValues: [senderKeys, json],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrDecryptEventConstMeta => const TaskConstMeta(
            debugName: "decrypt_event",
            argNames: ["senderKeys", "json"],
        );
        

@override Future<NostrEvent> crateApiNostrDecryptGift({required String senderKeys , required String receiver , required String content })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(senderKeys, serializer);
sse_encode_String(receiver, serializer);
sse_encode_String(content, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 32, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_nostr_event,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrDecryptGiftConstMeta,
            argValues: [senderKeys, receiver, content],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrDecryptGiftConstMeta => const TaskConstMeta(
            debugName: "decrypt_gift",
            argNames: ["senderKeys", "receiver", "content"],
        );
        

@override Future<DecryptedMessage> crateApiMlsDecryptMessage({required String nostrId , required String groupId , required String msg })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
sse_encode_String(msg, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 33, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_decrypted_message,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsDecryptMessageConstMeta,
            argValues: [nostrId, groupId, msg],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsDecryptMessageConstMeta => const TaskConstMeta(
            debugName: "decrypt_message",
            argNames: ["nostrId", "groupId", "msg"],
        );
        

@override Future<String> crateApiNostrDecryptNip44({required String secretKey , required String publicKey , required String content })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(secretKey, serializer);
sse_encode_String(publicKey, serializer);
sse_encode_String(content, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 34, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrDecryptNip44ConstMeta,
            argValues: [secretKey, publicKey, content],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrDecryptNip44ConstMeta => const TaskConstMeta(
            debugName: "decrypt_nip44",
            argNames: ["secretKey", "publicKey", "content"],
        );
        

@override Future<(Uint8List,String,List<String>?)> crateApiSignalDecryptSignal({required KeychatIdentityKeyPair keyPair , required List<int> ciphertext , required KeychatProtocolAddress remoteAddress , required int roomId , required bool isPrekey })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_list_prim_u_8_loose(ciphertext, serializer);
sse_encode_box_autoadd_keychat_protocol_address(remoteAddress, serializer);
sse_encode_u_32(roomId, serializer);
sse_encode_bool(isPrekey, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 35, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_list_prim_u_8_strict_string_opt_list_string,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalDecryptSignalConstMeta,
            argValues: [keyPair, ciphertext, remoteAddress, roomId, isPrekey],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalDecryptSignalConstMeta => const TaskConstMeta(
            debugName: "decrypt_signal",
            argNames: ["keyPair", "ciphertext", "remoteAddress", "roomId", "isPrekey"],
        );
        

@override Future<void> crateApiMlsDeleteGroup({required String nostrId , required String groupId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 36, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsDeleteGroupConstMeta,
            argValues: [nostrId, groupId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsDeleteGroupConstMeta => const TaskConstMeta(
            debugName: "delete_group",
            argNames: ["nostrId", "groupId"],
        );
        

@override Future<bool> crateApiSignalDeleteIdentity({required KeychatIdentityKeyPair keyPair , required String address })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_String(address, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 37, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalDeleteIdentityConstMeta,
            argValues: [keyPair, address],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalDeleteIdentityConstMeta => const TaskConstMeta(
            debugName: "delete_identity",
            argNames: ["keyPair", "address"],
        );
        

@override Future<void> crateApiMlsDeleteKeyPackage({required String nostrId , required String keyPackage })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(keyPackage, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 38, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsDeleteKeyPackageConstMeta,
            argValues: [nostrId, keyPackage],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsDeleteKeyPackageConstMeta => const TaskConstMeta(
            debugName: "delete_key_package",
            argNames: ["nostrId", "keyPackage"],
        );
        

@override Future<bool> crateApiSignalDeleteSession({required KeychatIdentityKeyPair keyPair , required KeychatProtocolAddress address })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_box_autoadd_keychat_protocol_address(address, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 39, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalDeleteSessionConstMeta,
            argValues: [keyPair, address],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalDeleteSessionConstMeta => const TaskConstMeta(
            debugName: "delete_session",
            argNames: ["keyPair", "address"],
        );
        

@override Future<bool> crateApiSignalDeleteSessionByDeviceId({required KeychatIdentityKeyPair keyPair , required int deviceId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_u_32(deviceId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 40, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalDeleteSessionByDeviceIdConstMeta,
            argValues: [keyPair, deviceId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalDeleteSessionByDeviceIdConstMeta => const TaskConstMeta(
            debugName: "delete_session_by_device_id",
            argNames: ["keyPair", "deviceId"],
        );
        

@override String crateApiNostrEncodeBech32({required String hrp , required String data })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(hrp, serializer);
sse_encode_String(data, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 41)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrEncodeBech32ConstMeta,
            argValues: [hrp, data],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrEncodeBech32ConstMeta => const TaskConstMeta(
            debugName: "encode_bech32",
            argNames: ["hrp", "data"],
        );
        

@override Future<String> crateApiNostrEncrypt({required String senderKeys , required String receiverPubkey , required String content })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(senderKeys, serializer);
sse_encode_String(receiverPubkey, serializer);
sse_encode_String(content, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 42, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrEncryptConstMeta,
            argValues: [senderKeys, receiverPubkey, content],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrEncryptConstMeta => const TaskConstMeta(
            debugName: "encrypt",
            argNames: ["senderKeys", "receiverPubkey", "content"],
        );
        

@override Future<String> crateApiNostrEncryptNip44({required String senderKeys , required String receiverPubkey , required String content })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(senderKeys, serializer);
sse_encode_String(receiverPubkey, serializer);
sse_encode_String(content, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 43, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrEncryptNip44ConstMeta,
            argValues: [senderKeys, receiverPubkey, content],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrEncryptNip44ConstMeta => const TaskConstMeta(
            debugName: "encrypt_nip44",
            argNames: ["senderKeys", "receiverPubkey", "content"],
        );
        

@override Future<(Uint8List,String?,String,List<String>?)> crateApiSignalEncryptSignal({required KeychatIdentityKeyPair keyPair , required String ptext , required KeychatProtocolAddress remoteAddress , bool? isPrekey })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_String(ptext, serializer);
sse_encode_box_autoadd_keychat_protocol_address(remoteAddress, serializer);
sse_encode_opt_box_autoadd_bool(isPrekey, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 44, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_list_prim_u_8_strict_opt_string_string_opt_list_string,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalEncryptSignalConstMeta,
            argValues: [keyPair, ptext, remoteAddress, isPrekey],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalEncryptSignalConstMeta => const TaskConstMeta(
            debugName: "encrypt_signal",
            argNames: ["keyPair", "ptext", "remoteAddress", "isPrekey"],
        );
        

@override Future<(Uint8List,Uint8List)> crateApiNostrGenerateCurve25519Keypair({required String mnemonicWords , String? password , int? pos })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(mnemonicWords, serializer);
sse_encode_opt_String(password, serializer);
sse_encode_opt_box_autoadd_u_32(pos, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 45, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_list_prim_u_8_strict_list_prim_u_8_strict,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrGenerateCurve25519KeypairConstMeta,
            argValues: [mnemonicWords, password, pos],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrGenerateCurve25519KeypairConstMeta => const TaskConstMeta(
            debugName: "generate_curve25519_keypair",
            argNames: ["mnemonicWords", "password", "pos"],
        );
        

@override Future<Secp256k1Account> crateApiNostrGenerateFromMnemonic({String? password })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_opt_String(password, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 46, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_secp_256_k_1_account,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrGenerateFromMnemonicConstMeta,
            argValues: [password],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrGenerateFromMnemonicConstMeta => const TaskConstMeta(
            debugName: "generate_from_mnemonic",
            argNames: ["password"],
        );
        

@override Future<String> crateApiNostrGenerateMessageKeyHash({required String seedKey })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(seedKey, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 47, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrGenerateMessageKeyHashConstMeta,
            argValues: [seedKey],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrGenerateMessageKeyHashConstMeta => const TaskConstMeta(
            debugName: "generate_message_key_hash",
            argNames: ["seedKey"],
        );
        

@override Future<(int,Uint8List,Uint8List)> crateApiSignalGeneratePrekeyApi({required KeychatIdentityKeyPair keyPair })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 48, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_u_32_list_prim_u_8_strict_list_prim_u_8_strict,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalGeneratePrekeyApiConstMeta,
            argValues: [keyPair],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalGeneratePrekeyApiConstMeta => const TaskConstMeta(
            debugName: "generate_prekey_api",
            argNames: ["keyPair"],
        );
        

@override Future<Secp256k1Account> crateApiNostrGenerateSecp256K1()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 49, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_secp_256_k_1_account,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrGenerateSecp256K1ConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrGenerateSecp256K1ConstMeta => const TaskConstMeta(
            debugName: "generate_secp256k1",
            argNames: [],
        );
        

@override Future<String> crateApiNostrGenerateSeedFromKey({required List<int> seedKey })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_list_prim_u_8_loose(seedKey, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 50, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrGenerateSeedFromKeyConstMeta,
            argValues: [seedKey],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrGenerateSeedFromKeyConstMeta => const TaskConstMeta(
            debugName: "generate_seed_from_key",
            argNames: ["seedKey"],
        );
        

@override Future<String> crateApiNostrGenerateSeedFromRatchetkeyPair({required String seedKey })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(seedKey, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 51, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrGenerateSeedFromRatchetkeyPairConstMeta,
            argValues: [seedKey],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrGenerateSeedFromRatchetkeyPairConstMeta => const TaskConstMeta(
            debugName: "generate_seed_from_ratchetkey_pair",
            argNames: ["seedKey"],
        );
        

@override Future<(Uint8List,Uint8List)> crateApiSignalGenerateSignalIds()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 52, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_list_prim_u_8_strict_list_prim_u_8_strict,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalGenerateSignalIdsConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalGenerateSignalIdsConstMeta => const TaskConstMeta(
            debugName: "generate_signal_ids",
            argNames: [],
        );
        

@override Future<(int,Uint8List,Uint8List,Uint8List)> crateApiSignalGenerateSignedKeyApi({required KeychatIdentityKeyPair keyPair , required List<int> signalIdentityPrivateKey })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_list_prim_u_8_loose(signalIdentityPrivateKey, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 53, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_u_32_list_prim_u_8_strict_list_prim_u_8_strict_list_prim_u_8_strict,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalGenerateSignedKeyApiConstMeta,
            argValues: [keyPair, signalIdentityPrivateKey],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalGenerateSignedKeyApiConstMeta => const TaskConstMeta(
            debugName: "generate_signed_key_api",
            argNames: ["keyPair", "signalIdentityPrivateKey"],
        );
        

@override Future<Secp256k1SimpleAccount> crateApiNostrGenerateSimple()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 54, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_secp_256_k_1_simple_account,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrGenerateSimpleConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrGenerateSimpleConstMeta => const TaskConstMeta(
            debugName: "generate_simple",
            argNames: [],
        );
        

@override Future<List<String>> crateApiSignalGetAllAliceAddrs({required KeychatIdentityKeyPair keyPair })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 55, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalGetAllAliceAddrsConstMeta,
            argValues: [keyPair],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalGetAllAliceAddrsConstMeta => const TaskConstMeta(
            debugName: "get_all_alice_addrs",
            argNames: ["keyPair"],
        );
        

@override Future<(BigInt,BigInt,BigInt)> crateApiCashuGetAllProofsData()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 56, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_usize_usize_usize,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuGetAllProofsDataConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuGetAllProofsDataConstMeta => const TaskConstMeta(
            debugName: "get_all_proofs_data",
            argNames: [],
        );
        

@override Future<List<Transaction>> crateApiCashuGetAllTransactions()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 57, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuGetAllTransactionsConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuGetAllTransactionsConstMeta => const TaskConstMeta(
            debugName: "get_all_transactions",
            argNames: [],
        );
        

@override Future<String> crateApiCashuGetBalances()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 58, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuGetBalancesConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuGetBalancesConstMeta => const TaskConstMeta(
            debugName: "get_balances",
            argNames: [],
        );
        

@override String crateApiNostrGetBech32PrikeyByHex({required String hex })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(hex, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 59)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiNostrGetBech32PrikeyByHexConstMeta,
            argValues: [hex],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrGetBech32PrikeyByHexConstMeta => const TaskConstMeta(
            debugName: "get_bech32_prikey_by_hex",
            argNames: ["hex"],
        );
        

@override String crateApiNostrGetBech32PubkeyByHex({required String hex })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(hex, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 60)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiNostrGetBech32PubkeyByHexConstMeta,
            argValues: [hex],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrGetBech32PubkeyByHexConstMeta => const TaskConstMeta(
            debugName: "get_bech32_pubkey_by_hex",
            argNames: ["hex"],
        );
        

@override Future<List<Transaction>> crateApiCashuGetCashuPendingTransactions()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 61, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuGetCashuPendingTransactionsConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuGetCashuPendingTransactionsConstMeta => const TaskConstMeta(
            debugName: "get_cashu_pending_transactions",
            argNames: [],
        );
        

@override Future<List<Transaction>> crateApiCashuGetCashuTransactionsWithOffset({required BigInt offset , required BigInt limit })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_usize(offset, serializer);
sse_encode_usize(limit, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 62, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuGetCashuTransactionsWithOffsetConstMeta,
            argValues: [offset, limit],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuGetCashuTransactionsWithOffsetConstMeta => const TaskConstMeta(
            debugName: "get_cashu_transactions_with_offset",
            argNames: ["offset", "limit"],
        );
        

@override Future<String> crateApiNostrGetEncryptEvent({required String senderKeys , required String receiverPubkey , required String content , String? reply })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(senderKeys, serializer);
sse_encode_String(receiverPubkey, serializer);
sse_encode_String(content, serializer);
sse_encode_opt_String(reply, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 63, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrGetEncryptEventConstMeta,
            argValues: [senderKeys, receiverPubkey, content, reply],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrGetEncryptEventConstMeta => const TaskConstMeta(
            debugName: "get_encrypt_event",
            argNames: ["senderKeys", "receiverPubkey", "content", "reply"],
        );
        

@override Future<Uint8List> crateApiMlsGetGroupConfig({required String nostrId , required String groupId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 64, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsGetGroupConfigConstMeta,
            argValues: [nostrId, groupId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsGetGroupConfigConstMeta => const TaskConstMeta(
            debugName: "get_group_config",
            argNames: ["nostrId", "groupId"],
        );
        

@override Future<GroupExtensionResult> crateApiMlsGetGroupExtension({required String nostrId , required String groupId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 65, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_group_extension_result,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsGetGroupExtensionConstMeta,
            argValues: [nostrId, groupId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsGetGroupExtensionConstMeta => const TaskConstMeta(
            debugName: "get_group_extension",
            argNames: ["nostrId", "groupId"],
        );
        

@override Future<List<String>> crateApiMlsGetGroupMembers({required String nostrId , required String groupId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 66, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsGetGroupMembersConstMeta,
            argValues: [nostrId, groupId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsGetGroupMembersConstMeta => const TaskConstMeta(
            debugName: "get_group_members",
            argNames: ["nostrId", "groupId"],
        );
        

@override Future<Map<String, BigInt?>> crateApiMlsGetGroupMembersWithLifetime({required String nostrId , required String groupId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 67, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Map_String_opt_box_autoadd_u_64_None,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsGetGroupMembersWithLifetimeConstMeta,
            argValues: [nostrId, groupId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsGetGroupMembersWithLifetimeConstMeta => const TaskConstMeta(
            debugName: "get_group_members_with_lifetime",
            argNames: ["nostrId", "groupId"],
        );
        

@override String crateApiNostrGetHexPrikeyByBech32({required String bech32 })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(bech32, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 68)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiNostrGetHexPrikeyByBech32ConstMeta,
            argValues: [bech32],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrGetHexPrikeyByBech32ConstMeta => const TaskConstMeta(
            debugName: "get_hex_prikey_by_bech32",
            argNames: ["bech32"],
        );
        

@override String crateApiNostrGetHexPubkeyByBech32({required String bech32 })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(bech32, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 69)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiNostrGetHexPubkeyByBech32ConstMeta,
            argValues: [bech32],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrGetHexPubkeyByBech32ConstMeta => const TaskConstMeta(
            debugName: "get_hex_pubkey_by_bech32",
            argNames: ["bech32"],
        );
        

@override String crateApiNostrGetHexPubkeyByPrikey({required String prikey })  { return handler.executeSync(SyncTask(
            callFfi: () {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(prikey, serializer);
            return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 70)!;
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrGetHexPubkeyByPrikeyConstMeta,
            argValues: [prikey],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrGetHexPubkeyByPrikeyConstMeta => const TaskConstMeta(
            debugName: "get_hex_pubkey_by_prikey",
            argNames: ["prikey"],
        );
        

@override Future<KeychatIdentityKey?> crateApiSignalGetIdentity({required KeychatIdentityKeyPair keyPair , required KeychatProtocolAddress address })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_box_autoadd_keychat_protocol_address(address, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 71, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_keychat_identity_key,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalGetIdentityConstMeta,
            argValues: [keyPair, address],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalGetIdentityConstMeta => const TaskConstMeta(
            debugName: "get_identity",
            argNames: ["keyPair", "address"],
        );
        

@override Future<Uint8List> crateApiMlsGetLeadNodeIndex({required String nostrIdAdmin , required String nostrIdCommon , required String groupId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrIdAdmin, serializer);
sse_encode_String(nostrIdCommon, serializer);
sse_encode_String(groupId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 72, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsGetLeadNodeIndexConstMeta,
            argValues: [nostrIdAdmin, nostrIdCommon, groupId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsGetLeadNodeIndexConstMeta => const TaskConstMeta(
            debugName: "get_lead_node_index",
            argNames: ["nostrIdAdmin", "nostrIdCommon", "groupId"],
        );
        

@override Future<String> crateApiMlsGetListenKeyFromExportSecret({required String nostrId , required String groupId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 73, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsGetListenKeyFromExportSecretConstMeta,
            argValues: [nostrId, groupId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsGetListenKeyFromExportSecretConstMeta => const TaskConstMeta(
            debugName: "get_listen_key_from_export_secret",
            argNames: ["nostrId", "groupId"],
        );
        

@override Future<List<Transaction>> crateApiCashuGetLnPendingTransactions()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 74, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuGetLnPendingTransactionsConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuGetLnPendingTransactionsConstMeta => const TaskConstMeta(
            debugName: "get_ln_pending_transactions",
            argNames: [],
        );
        

@override Future<List<Transaction>> crateApiCashuGetLnTransactionsWithOffset({required BigInt offset , required BigInt limit })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_usize(offset, serializer);
sse_encode_usize(limit, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 75, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuGetLnTransactionsWithOffsetConstMeta,
            argValues: [offset, limit],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuGetLnTransactionsWithOffsetConstMeta => const TaskConstMeta(
            debugName: "get_ln_transactions_with_offset",
            argNames: ["offset", "limit"],
        );
        

@override Future<Map<String, List<Uint8List>>> crateApiMlsGetMemberExtension({required String nostrId , required String groupId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 76, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Map_String_list_list_prim_u_8_strict_None,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsGetMemberExtensionConstMeta,
            argValues: [nostrId, groupId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsGetMemberExtensionConstMeta => const TaskConstMeta(
            debugName: "get_member_extension",
            argNames: ["nostrId", "groupId"],
        );
        

@override Future<List<MintCashu>> crateApiCashuGetMints()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 77, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_mint_cashu,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuGetMintsConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuGetMintsConstMeta => const TaskConstMeta(
            debugName: "get_mints",
            argNames: [],
        );
        

@override Future<BigInt> crateApiCashuGetPendingTransactionsCount()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 78, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuGetPendingTransactionsCountConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuGetPendingTransactionsCountConstMeta => const TaskConstMeta(
            debugName: "get_pending_transactions_count",
            argNames: [],
        );
        

@override Future<Uint8List> crateApiSignalGetPrekeyApi({required KeychatIdentityKeyPair keyPair , required int prekeyId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_u_32(prekeyId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 79, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalGetPrekeyApiConstMeta,
            argValues: [keyPair, prekeyId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalGetPrekeyApiConstMeta => const TaskConstMeta(
            debugName: "get_prekey_api",
            argNames: ["keyPair", "prekeyId"],
        );
        

@override Future<String?> crateApiMlsGetSender({required String nostrId , required String groupId , required String queuedMsg })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
sse_encode_String(queuedMsg, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 80, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsGetSenderConstMeta,
            argValues: [nostrId, groupId, queuedMsg],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsGetSenderConstMeta => const TaskConstMeta(
            debugName: "get_sender",
            argNames: ["nostrId", "groupId", "queuedMsg"],
        );
        

@override Future<KeychatSignalSession?> crateApiSignalGetSession({required KeychatIdentityKeyPair keyPair , required String address , required String deviceId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_String(address, serializer);
sse_encode_String(deviceId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 81, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_keychat_signal_session,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalGetSessionConstMeta,
            argValues: [keyPair, address, deviceId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalGetSessionConstMeta => const TaskConstMeta(
            debugName: "get_session",
            argNames: ["keyPair", "address", "deviceId"],
        );
        

@override Future<Uint8List> crateApiSignalGetSignedKeyApi({required KeychatIdentityKeyPair keyPair , required int signedKeyId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_u_32(signedKeyId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 82, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalGetSignedKeyApiConstMeta,
            argValues: [keyPair, signedKeyId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalGetSignedKeyApiConstMeta => const TaskConstMeta(
            debugName: "get_signed_key_api",
            argNames: ["keyPair", "signedKeyId"],
        );
        

@override Future<Uint8List> crateApiMlsGetTreeHash({required String nostrId , required String groupId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 83, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsGetTreeHashConstMeta,
            argValues: [nostrId, groupId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsGetTreeHashConstMeta => const TaskConstMeta(
            debugName: "get_tree_hash",
            argNames: ["nostrId", "groupId"],
        );
        

@override Future<String> crateApiNostrGetUnencryptEvent({required String senderKeys , required List<String> receiverPubkeys , required String content , required int kind , List<List<String>>? additionalTags })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(senderKeys, serializer);
sse_encode_list_String(receiverPubkeys, serializer);
sse_encode_String(content, serializer);
sse_encode_u_16(kind, serializer);
sse_encode_opt_list_list_String(additionalTags, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 84, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrGetUnencryptEventConstMeta,
            argValues: [senderKeys, receiverPubkeys, content, kind, additionalTags],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrGetUnencryptEventConstMeta => const TaskConstMeta(
            debugName: "get_unencrypt_event",
            argNames: ["senderKeys", "receiverPubkeys", "content", "kind", "additionalTags"],
        );
        

@override Future<Wallet> crateApiCashuGetWalletByIndex({required MultiMintWallet multiMintWallet , required List<(MintUrl,Amount)> mintAmounts , required BigInt mintNumber , required CurrencyUnit unit })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiMintWallet(multiMintWallet, serializer);
sse_encode_list_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_mint_url_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_amount(mintAmounts, serializer);
sse_encode_usize(mintNumber, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCurrencyUnit(unit, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 85, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWallet,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuGetWalletByIndexConstMeta,
            argValues: [multiMintWallet, mintAmounts, mintNumber, unit],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuGetWalletByIndexConstMeta => const TaskConstMeta(
            debugName: "get_wallet_by_index",
            argNames: ["multiMintWallet", "mintAmounts", "mintNumber", "unit"],
        );
        

@override Future<Secp256k1Account> crateApiNostrImportFromPhrase({required String phrase , String? password , int? account })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(phrase, serializer);
sse_encode_opt_String(password, serializer);
sse_encode_opt_box_autoadd_u_32(account, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 86, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_secp_256_k_1_account,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrImportFromPhraseConstMeta,
            argValues: [phrase, password, account],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrImportFromPhraseConstMeta => const TaskConstMeta(
            debugName: "import_from_phrase",
            argNames: ["phrase", "password", "account"],
        );
        

@override Future<List<Secp256k1Account>> crateApiNostrImportFromPhraseWith({required String phrase , String? password , required int offset , required int count })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(phrase, serializer);
sse_encode_opt_String(password, serializer);
sse_encode_u_32(offset, serializer);
sse_encode_u_32(count, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 87, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_secp_256_k_1_account,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrImportFromPhraseWithConstMeta,
            argValues: [phrase, password, offset, count],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrImportFromPhraseWithConstMeta => const TaskConstMeta(
            debugName: "import_from_phrase_with",
            argNames: ["phrase", "password", "offset", "count"],
        );
        

@override Future<Secp256k1Account> crateApiNostrImportKey({required String senderKeys })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(senderKeys, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 88, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_secp_256_k_1_account,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrImportKeyConstMeta,
            argValues: [senderKeys],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrImportKeyConstMeta => const TaskConstMeta(
            debugName: "import_key",
            argNames: ["senderKeys"],
        );
        

@override Future<void> crateApiSignalInit({required String dbPath , required KeychatIdentityKeyPair keyPair , required int regId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dbPath, serializer);
sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_u_32(regId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 89, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalInitConstMeta,
            argValues: [dbPath, keyPair, regId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalInitConstMeta => const TaskConstMeta(
            debugName: "init",
            argNames: ["dbPath", "keyPair", "regId"],
        );
        

@override Future<List<MintCashu>> crateApiCashuInitCashu({required int prepareSatsOnceTime })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_16(prepareSatsOnceTime, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 90, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_mint_cashu,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuInitCashuConstMeta,
            argValues: [prepareSatsOnceTime],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuInitCashuConstMeta => const TaskConstMeta(
            debugName: "init_cashu",
            argNames: ["prepareSatsOnceTime"],
        );
        

@override Future<void> crateApiCashuInitDb({required String dbpath , required String words , required bool dev })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dbpath, serializer);
sse_encode_String(words, serializer);
sse_encode_bool(dev, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 91, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuInitDbConstMeta,
            argValues: [dbpath, words, dev],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuInitDbConstMeta => const TaskConstMeta(
            debugName: "init_db",
            argNames: ["dbpath", "words", "dev"],
        );
        

@override Future<void> crateApiCashuInitDbCashuOnce({required String dbpath })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dbpath, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 92, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuInitDbCashuOnceConstMeta,
            argValues: [dbpath],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuInitDbCashuOnceConstMeta => const TaskConstMeta(
            debugName: "init_db_cashu_once",
            argNames: ["dbpath"],
        );
        

@override Future<void> crateApiSignalInitKeypair({required KeychatIdentityKeyPair keyPair , required int regId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_u_32(regId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 93, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalInitKeypairConstMeta,
            argValues: [keyPair, regId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalInitKeypairConstMeta => const TaskConstMeta(
            debugName: "init_keypair",
            argNames: ["keyPair", "regId"],
        );
        

@override Future<void> crateApiMlsInitMlsDb({required String dbPath , required String nostrId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dbPath, serializer);
sse_encode_String(nostrId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 94, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsInitMlsDbConstMeta,
            argValues: [dbPath, nostrId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsInitMlsDbConstMeta => const TaskConstMeta(
            debugName: "init_mls_db",
            argNames: ["dbPath", "nostrId"],
        );
        

@override Future<void> crateApiSignalInitSignalDb({required String dbPath })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dbPath, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 95, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalInitSignalDbConstMeta,
            argValues: [dbPath],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalInitSignalDbConstMeta => const TaskConstMeta(
            debugName: "init_signal_db",
            argNames: ["dbPath"],
        );
        

@override Future<void> crateApiMlsJoinMlsGroup({required String nostrId , required String groupId , required List<int> welcome })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
sse_encode_list_prim_u_8_loose(welcome, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 96, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsJoinMlsGroupConstMeta,
            argValues: [nostrId, groupId, welcome],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsJoinMlsGroupConstMeta => const TaskConstMeta(
            debugName: "join_mls_group",
            argNames: ["nostrId", "groupId", "welcome"],
        );
        

@override Future<Transaction> crateApiCashuMelt({required String invoice , required String activeMint , BigInt? amount })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(invoice, serializer);
sse_encode_String(activeMint, serializer);
sse_encode_opt_box_autoadd_u_64(amount, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 97, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuMeltConstMeta,
            argValues: [invoice, activeMint, amount],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuMeltConstMeta => const TaskConstMeta(
            debugName: "melt",
            argNames: ["invoice", "activeMint", "amount"],
        );
        

@override Future<void> crateApiCashuMergeProofs({required BigInt thershold })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_64(thershold, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 98, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuMergeProofsConstMeta,
            argValues: [thershold],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuMergeProofsConstMeta => const TaskConstMeta(
            debugName: "merge_proofs",
            argNames: ["thershold"],
        );
        

@override Future<MintCashuInfo> crateApiCashuTypesMintCashuInfoDefault()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 99, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_mint_cashu_info,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiCashuTypesMintCashuInfoDefaultConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuTypesMintCashuInfoDefaultConstMeta => const TaskConstMeta(
            debugName: "mint_cashu_info_default",
            argNames: [],
        );
        

@override Future<Transaction> crateApiCashuMintToken({required BigInt amount , required String quoteId , required String activeMint })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_64(amount, serializer);
sse_encode_String(quoteId, serializer);
sse_encode_String(activeMint, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 100, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuMintTokenConstMeta,
            argValues: [amount, quoteId, activeMint],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuMintTokenConstMeta => const TaskConstMeta(
            debugName: "mint_token",
            argNames: ["amount", "quoteId", "activeMint"],
        );
        

@override Future<void> crateApiCashuMultiReceive({required List<String> stamps })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_list_String(stamps, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 101, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuMultiReceiveConstMeta,
            argValues: [stamps],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuMultiReceiveConstMeta => const TaskConstMeta(
            debugName: "multi_receive",
            argNames: ["stamps"],
        );
        

@override Future<String> crateApiNostrNip47EncodeUri({required String pubkey , required String relay , required String secret , String? lud16 })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(pubkey, serializer);
sse_encode_String(relay, serializer);
sse_encode_String(secret, serializer);
sse_encode_opt_String(lud16, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 102, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrNip47EncodeUriConstMeta,
            argValues: [pubkey, relay, secret, lud16],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrNip47EncodeUriConstMeta => const TaskConstMeta(
            debugName: "nip47_encode_uri",
            argNames: ["pubkey", "relay", "secret", "lud16"],
        );
        

@override Future<String> crateApiNostrNip47ParseRequest({required String request })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(request, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 103, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrNip47ParseRequestConstMeta,
            argValues: [request],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrNip47ParseRequestConstMeta => const TaskConstMeta(
            debugName: "nip47_parse_request",
            argNames: ["request"],
        );
        

@override Future<void> crateApiMlsNormalMemberCommitLeave({required String nostrId , required String groupId , required List<int> queuedMsg })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
sse_encode_list_prim_u_8_loose(queuedMsg, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 104, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsNormalMemberCommitLeaveConstMeta,
            argValues: [nostrId, groupId, queuedMsg],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsNormalMemberCommitLeaveConstMeta => const TaskConstMeta(
            debugName: "normal_member_commit_leave",
            argNames: ["nostrId", "groupId", "queuedMsg"],
        );
        

@override Future<CommitResult> crateApiMlsOthersCommitNormal({required String nostrId , required String groupId , required String queuedMsg })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
sse_encode_String(queuedMsg, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 105, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_commit_result,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsOthersCommitNormalConstMeta,
            argValues: [nostrId, groupId, queuedMsg],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsOthersCommitNormalConstMeta => const TaskConstMeta(
            debugName: "others_commit_normal",
            argNames: ["nostrId", "groupId", "queuedMsg"],
        );
        

@override Future<void> crateApiMlsOthersProposalLeave({required String nostrId , required String groupId , required List<int> queuedMsg })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
sse_encode_list_prim_u_8_loose(queuedMsg, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 106, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsOthersProposalLeaveConstMeta,
            argValues: [nostrId, groupId, queuedMsg],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsOthersProposalLeaveConstMeta => const TaskConstMeta(
            debugName: "others_proposal_leave",
            argNames: ["nostrId", "groupId", "queuedMsg"],
        );
        

@override Future<(String,int)> crateApiSignalParseIdentityFromPrekeySignalMessage({required List<int> ciphertext })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_list_prim_u_8_loose(ciphertext, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 107, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_string_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalParseIdentityFromPrekeySignalMessageConstMeta,
            argValues: [ciphertext],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalParseIdentityFromPrekeySignalMessageConstMeta => const TaskConstMeta(
            debugName: "parse_identity_from_prekey_signal_message",
            argNames: ["ciphertext"],
        );
        

@override Future<bool> crateApiSignalParseIsPrekeySignalMessage({required List<int> ciphertext })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_list_prim_u_8_loose(ciphertext, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 108, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalParseIsPrekeySignalMessageConstMeta,
            argValues: [ciphertext],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalParseIsPrekeySignalMessageConstMeta => const TaskConstMeta(
            debugName: "parse_is_prekey_signal_message",
            argNames: ["ciphertext"],
        );
        

@override Future<BigInt> crateApiMlsParseLifetimeFromKeyPackage({required String nostrId , required String keyPackageHex })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(keyPackageHex, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 109, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsParseLifetimeFromKeyPackageConstMeta,
            argValues: [nostrId, keyPackageHex],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsParseLifetimeFromKeyPackageConstMeta => const TaskConstMeta(
            debugName: "parse_lifetime_from_key_package",
            argNames: ["nostrId", "keyPackageHex"],
        );
        

@override Future<MessageInType> crateApiMlsParseMlsMsgType({required String nostrId , required String groupId , required String data })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
sse_encode_String(data, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 110, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_message_in_type,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsParseMlsMsgTypeConstMeta,
            argValues: [nostrId, groupId, data],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsParseMlsMsgTypeConstMeta => const TaskConstMeta(
            debugName: "parse_mls_msg_type",
            argNames: ["nostrId", "groupId", "data"],
        );
        

@override Future<BigInt> crateApiCashuPrepareOneProofs({required BigInt amount , required String mint })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_64(amount, serializer);
sse_encode_String(mint, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 111, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuPrepareOneProofsConstMeta,
            argValues: [amount, mint],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuPrepareOneProofsConstMeta => const TaskConstMeta(
            debugName: "prepare_one_proofs",
            argNames: ["amount", "mint"],
        );
        

@override Future<void> crateApiCashuPrintProofs({required String mint })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(mint, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 112, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuPrintProofsConstMeta,
            argValues: [mint],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuPrintProofsConstMeta => const TaskConstMeta(
            debugName: "print_proofs",
            argNames: ["mint"],
        );
        

@override Future<void> crateApiSignalProcessPrekeyBundleApi({required KeychatIdentityKeyPair keyPair , required KeychatProtocolAddress remoteAddress , required int regId , required int deviceId , required KeychatIdentityKey identityKey , required int bobSignedId , required List<int> bobSignedPublic , required List<int> bobSigedSig , required int bobPrekeyId , required List<int> bobPrekeyPublic })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_box_autoadd_keychat_protocol_address(remoteAddress, serializer);
sse_encode_u_32(regId, serializer);
sse_encode_u_32(deviceId, serializer);
sse_encode_box_autoadd_keychat_identity_key(identityKey, serializer);
sse_encode_u_32(bobSignedId, serializer);
sse_encode_list_prim_u_8_loose(bobSignedPublic, serializer);
sse_encode_list_prim_u_8_loose(bobSigedSig, serializer);
sse_encode_u_32(bobPrekeyId, serializer);
sse_encode_list_prim_u_8_loose(bobPrekeyPublic, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 113, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalProcessPrekeyBundleApiConstMeta,
            argValues: [keyPair, remoteAddress, regId, deviceId, identityKey, bobSignedId, bobSignedPublic, bobSigedSig, bobPrekeyId, bobPrekeyPublic],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalProcessPrekeyBundleApiConstMeta => const TaskConstMeta(
            debugName: "process_prekey_bundle_api",
            argNames: ["keyPair", "remoteAddress", "regId", "deviceId", "identityKey", "bobSignedId", "bobSignedPublic", "bobSigedSig", "bobPrekeyId", "bobPrekeyPublic"],
        );
        

@override Future<Transaction> crateApiCashuReceiveToken({required String encodedToken })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(encodedToken, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 114, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuReceiveTokenConstMeta,
            argValues: [encodedToken],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuReceiveTokenConstMeta => const TaskConstMeta(
            debugName: "receive_token",
            argNames: ["encodedToken"],
        );
        

@override Future<String> crateApiMlsRemoveMembers({required String nostrId , required String groupId , required List<Uint8List> members })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
sse_encode_list_list_prim_u_8_strict(members, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 115, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsRemoveMembersConstMeta,
            argValues: [nostrId, groupId, members],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsRemoveMembersConstMeta => const TaskConstMeta(
            debugName: "remove_members",
            argNames: ["nostrId", "groupId", "members"],
        );
        

@override Future<void> crateApiCashuRemoveMint({required String url })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(url, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 116, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuRemoveMintConstMeta,
            argValues: [url],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuRemoveMintConstMeta => const TaskConstMeta(
            debugName: "remove_mint",
            argNames: ["url"],
        );
        

@override Future<void> crateApiCashuRemoveTransactions({required BigInt unixTimestampLe , required TransactionStatus status })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_64(unixTimestampLe, serializer);
sse_encode_transaction_status(status, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 117, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuRemoveTransactionsConstMeta,
            argValues: [unixTimestampLe, status],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuRemoveTransactionsConstMeta => const TaskConstMeta(
            debugName: "remove_transactions",
            argNames: ["unixTimestampLe", "status"],
        );
        

@override Future<Transaction> crateApiCashuRequestMint({required BigInt amount , required String activeMint })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_64(amount, serializer);
sse_encode_String(activeMint, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 118, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuRequestMintConstMeta,
            argValues: [amount, activeMint],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuRequestMintConstMeta => const TaskConstMeta(
            debugName: "request_mint",
            argNames: ["amount", "activeMint"],
        );
        

@override Future<(BigInt,BigInt)> crateApiCashuRestore({required String mintUrl , String? words })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(mintUrl, serializer);
sse_encode_opt_String(words, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 119, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_u_64_u_64,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuRestoreConstMeta,
            argValues: [mintUrl, words],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuRestoreConstMeta => const TaskConstMeta(
            debugName: "restore",
            argNames: ["mintUrl", "words"],
        );
        

@override Future<void> crateApiMlsSelfCommit({required String nostrId , required String groupId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 120, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsSelfCommitConstMeta,
            argValues: [nostrId, groupId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsSelfCommitConstMeta => const TaskConstMeta(
            debugName: "self_commit",
            argNames: ["nostrId", "groupId"],
        );
        

@override Future<Uint8List> crateApiMlsSelfLeave({required String nostrId , required String groupId })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 121, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsSelfLeaveConstMeta,
            argValues: [nostrId, groupId],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsSelfLeaveConstMeta => const TaskConstMeta(
            debugName: "self_leave",
            argNames: ["nostrId", "groupId"],
        );
        

@override Future<String> crateApiMlsSelfUpdate({required String nostrId , required String groupId , required List<int> extensions })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
sse_encode_list_prim_u_8_loose(extensions, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 122, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsSelfUpdateConstMeta,
            argValues: [nostrId, groupId, extensions],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsSelfUpdateConstMeta => const TaskConstMeta(
            debugName: "self_update",
            argNames: ["nostrId", "groupId", "extensions"],
        );
        

@override Future<Transaction> crateApiCashuSend({required BigInt amount , required String activeMint , String? info })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_64(amount, serializer);
sse_encode_String(activeMint, serializer);
sse_encode_opt_String(info, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 123, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuSendConstMeta,
            argValues: [amount, activeMint, info],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuSendConstMeta => const TaskConstMeta(
            debugName: "send",
            argNames: ["amount", "activeMint", "info"],
        );
        

@override Future<Transaction> crateApiCashuSendAll({required String mint })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(mint, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 124, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuSendAllConstMeta,
            argValues: [mint],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuSendAllConstMeta => const TaskConstMeta(
            debugName: "send_all",
            argNames: ["mint"],
        );
        

@override Future<Transaction> crateApiCashuSendStamp({required BigInt amount , required List<String> mints , String? info })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_u_64(amount, serializer);
sse_encode_list_String(mints, serializer);
sse_encode_opt_String(info, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 125, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_transaction,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuSendStampConstMeta,
            argValues: [amount, mints, info],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuSendStampConstMeta => const TaskConstMeta(
            debugName: "send_stamp",
            argNames: ["amount", "mints", "info"],
        );
        

@override Future<KeychatSignalSession?> crateApiSignalSessionContainAliceAddr({required KeychatIdentityKeyPair keyPair , required String address })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_String(address, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 126, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_keychat_signal_session,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalSessionContainAliceAddrConstMeta,
            argValues: [keyPair, address],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalSessionContainAliceAddrConstMeta => const TaskConstMeta(
            debugName: "session_contain_alice_addr",
            argNames: ["keyPair", "address"],
        );
        

@override Future<bool> crateApiCashuSetMnemonic({String? words })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_opt_String(words, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 127, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuSetMnemonicConstMeta,
            argValues: [words],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuSetMnemonicConstMeta => const TaskConstMeta(
            debugName: "set_mnemonic",
            argNames: ["words"],
        );
        

@override Future<String> crateApiNostrSha1Hash({required String data })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(data, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 128, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiNostrSha1HashConstMeta,
            argValues: [data],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrSha1HashConstMeta => const TaskConstMeta(
            debugName: "sha1_hash",
            argNames: ["data"],
        );
        

@override Future<String> crateApiNostrSha256Hash({required String data })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(data, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 129, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiNostrSha256HashConstMeta,
            argValues: [data],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrSha256HashConstMeta => const TaskConstMeta(
            debugName: "sha256_hash",
            argNames: ["data"],
        );
        

@override Future<String> crateApiNostrSha256HashBytes({required List<int> data })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_list_prim_u_8_loose(data, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 130, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiNostrSha256HashBytesConstMeta,
            argValues: [data],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrSha256HashBytesConstMeta => const TaskConstMeta(
            debugName: "sha256_hash_bytes",
            argNames: ["data"],
        );
        

@override Future<String> crateApiNostrSignEvent({required String senderKeys , required String content , required BigInt createdAt , required int kind , required List<List<String>> tags })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(senderKeys, serializer);
sse_encode_String(content, serializer);
sse_encode_u_64(createdAt, serializer);
sse_encode_u_16(kind, serializer);
sse_encode_list_list_String(tags, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 131, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrSignEventConstMeta,
            argValues: [senderKeys, content, createdAt, kind, tags],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrSignEventConstMeta => const TaskConstMeta(
            debugName: "sign_event",
            argNames: ["senderKeys", "content", "createdAt", "kind", "tags"],
        );
        

@override Future<String> crateApiNostrSignSchnorr({required String privateKey , required String content })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(privateKey, serializer);
sse_encode_String(content, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 132, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrSignSchnorrConstMeta,
            argValues: [privateKey, content],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrSignSchnorrConstMeta => const TaskConstMeta(
            debugName: "sign_schnorr",
            argNames: ["privateKey", "content"],
        );
        

@override Future<void> crateApiSignalStorePrekeyApi({required KeychatIdentityKeyPair keyPair , required int prekeyId , required List<int> record })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_u_32(prekeyId, serializer);
sse_encode_list_prim_u_8_loose(record, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 133, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalStorePrekeyApiConstMeta,
            argValues: [keyPair, prekeyId, record],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalStorePrekeyApiConstMeta => const TaskConstMeta(
            debugName: "store_prekey_api",
            argNames: ["keyPair", "prekeyId", "record"],
        );
        

@override Future<void> crateApiSignalStoreSignedKeyApi({required KeychatIdentityKeyPair keyPair , required int signedKeyId , required List<int> record })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_u_32(signedKeyId, serializer);
sse_encode_list_prim_u_8_loose(record, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 134, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalStoreSignedKeyApiConstMeta,
            argValues: [keyPair, signedKeyId, record],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalStoreSignedKeyApiConstMeta => const TaskConstMeta(
            debugName: "store_signed_key_api",
            argNames: ["keyPair", "signedKeyId", "record"],
        );
        

@override Future<(List<String>,Set<String>)> crateApiCashuV1TryUnreachableMints({required String dbpath , String? words , required List<String> mints })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(dbpath, serializer);
sse_encode_opt_String(words, serializer);
sse_encode_list_String(mints, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 135, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_record_list_string_set_string_none,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuV1TryUnreachableMintsConstMeta,
            argValues: [dbpath, words, mints],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuV1TryUnreachableMintsConstMeta => const TaskConstMeta(
            debugName: "try_unreachable_mints",
            argNames: ["dbpath", "words", "mints"],
        );
        

@override Future<bool> crateApiSignalUpdateAliceAddr({required KeychatIdentityKeyPair keyPair , required String address , required String deviceId , required String aliceAddr })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_box_autoadd_keychat_identity_key_pair(keyPair, serializer);
sse_encode_String(address, serializer);
sse_encode_String(deviceId, serializer);
sse_encode_String(aliceAddr, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 136, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiSignalUpdateAliceAddrConstMeta,
            argValues: [keyPair, address, deviceId, aliceAddr],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiSignalUpdateAliceAddrConstMeta => const TaskConstMeta(
            debugName: "update_alice_addr",
            argNames: ["keyPair", "address", "deviceId", "aliceAddr"],
        );
        

@override Future<String> crateApiMlsUpdateGroupContextExtensions({required String nostrId , required String groupId , String? groupName , String? description , List<String>? adminPubkeysHex , List<String>? groupRelays , String? status })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(nostrId, serializer);
sse_encode_String(groupId, serializer);
sse_encode_opt_String(groupName, serializer);
sse_encode_opt_String(description, serializer);
sse_encode_opt_list_String(adminPubkeysHex, serializer);
sse_encode_opt_list_String(groupRelays, serializer);
sse_encode_opt_String(status, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 137, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiMlsUpdateGroupContextExtensionsConstMeta,
            argValues: [nostrId, groupId, groupName, description, adminPubkeysHex, groupRelays, status],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiMlsUpdateGroupContextExtensionsConstMeta => const TaskConstMeta(
            debugName: "update_group_context_extensions",
            argNames: ["nostrId", "groupId", "groupName", "description", "adminPubkeysHex", "groupRelays", "status"],
        );
        

@override Future<void> crateApiCashuValidateMintNumber({required BigInt mintNumber , required BigInt mintCount })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_usize(mintNumber, serializer);
sse_encode_usize(mintCount, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 138, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiCashuValidateMintNumberConstMeta,
            argValues: [mintNumber, mintCount],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCashuValidateMintNumberConstMeta => const TaskConstMeta(
            debugName: "validate_mint_number",
            argNames: ["mintNumber", "mintCount"],
        );
        

@override Future<NostrEvent> crateApiNostrVerifyEvent({required String json })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(json, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 139, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_nostr_event,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrVerifyEventConstMeta,
            argValues: [json],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrVerifyEventConstMeta => const TaskConstMeta(
            debugName: "verify_event",
            argNames: ["json"],
        );
        

@override Future<bool> crateApiNostrVerifySchnorr({required String pubkey , required String sig , required String content , required bool hash })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(pubkey, serializer);
sse_encode_String(sig, serializer);
sse_encode_String(content, serializer);
sse_encode_bool(hash, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 140, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        )
        ,
            constMeta: kCrateApiNostrVerifySchnorrConstMeta,
            argValues: [pubkey, sig, content, hash],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiNostrVerifySchnorrConstMeta => const TaskConstMeta(
            debugName: "verify_schnorr",
            argNames: ["pubkey", "sig", "content", "hash"],
        );
        

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Amount => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAmount;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Amount => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAmount;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_CurrencyUnit => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCurrencyUnit;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_CurrencyUnit => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCurrencyUnit;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_MintUrl => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMintUrl;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_MintUrl => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMintUrl;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Mnemonic => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Mnemonic => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_MnemonicInfo => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonicInfo;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_MnemonicInfo => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonicInfo;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_MultiMintWallet => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiMintWallet;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_MultiMintWallet => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiMintWallet;

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Wallet => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWallet;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Wallet => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWallet;



                  @protected AnyhowException dco_decode_AnyhowException(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return AnyhowException(raw as String); }

@protected Amount dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAmount(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return AmountImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected CurrencyUnit dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCurrencyUnit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return CurrencyUnitImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected MintUrl dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMintUrl(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MintUrlImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected MnemonicInfo dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonicInfo(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MnemonicInfoImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Wallet dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWallet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WalletImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Mnemonic dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MnemonicImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected MnemonicInfo dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonicInfo(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MnemonicInfoImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected MultiMintWallet dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiMintWallet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MultiMintWalletImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Map<String, String> dco_decode_Map_String_String_None(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Map.fromEntries(dco_decode_list_record_string_string(raw).map((e) => MapEntry(e.$1, e.$2))); }

@protected Map<String, bool> dco_decode_Map_String_bool_None(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Map.fromEntries(dco_decode_list_record_string_bool(raw).map((e) => MapEntry(e.$1, e.$2))); }

@protected Map<String, List<Uint8List>> dco_decode_Map_String_list_list_prim_u_8_strict_None(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Map.fromEntries(dco_decode_list_record_string_list_list_prim_u_8_strict(raw).map((e) => MapEntry(e.$1, e.$2))); }

@protected Map<String, BigInt?> dco_decode_Map_String_opt_box_autoadd_u_64_None(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Map.fromEntries(dco_decode_list_record_string_opt_box_autoadd_u_64(raw).map((e) => MapEntry(e.$1, e.$2))); }

@protected Amount dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAmount(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return AmountImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected CurrencyUnit dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCurrencyUnit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return CurrencyUnitImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected MintUrl dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMintUrl(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MintUrlImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Mnemonic dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MnemonicImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected MnemonicInfo dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonicInfo(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MnemonicInfoImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected MultiMintWallet dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiMintWallet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MultiMintWalletImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Wallet dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWallet(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return WalletImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected Set<String> dco_decode_Set_String_None(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return Set.from(dco_decode_list_String(raw)); }

@protected String dco_decode_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as String; }

@protected AddMembersResult dco_decode_add_members_result(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return AddMembersResult(queuedMsg: dco_decode_String(arr[0]),
welcome: dco_decode_list_prim_u_8_strict(arr[1]),); }

@protected bool dco_decode_bool(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as bool; }

@protected bool dco_decode_box_autoadd_bool(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as bool; }

@protected KeychatIdentityKey dco_decode_box_autoadd_keychat_identity_key(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_keychat_identity_key(raw); }

@protected KeychatIdentityKeyPair dco_decode_box_autoadd_keychat_identity_key_pair(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_keychat_identity_key_pair(raw); }

@protected KeychatProtocolAddress dco_decode_box_autoadd_keychat_protocol_address(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_keychat_protocol_address(raw); }

@protected KeychatSignalSession dco_decode_box_autoadd_keychat_signal_session(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_keychat_signal_session(raw); }

@protected MintCashuInfo dco_decode_box_autoadd_mint_cashu_info(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_mint_cashu_info(raw); }

@protected int dco_decode_box_autoadd_u_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected BigInt dco_decode_box_autoadd_u_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_u_64(raw); }

@protected CashuV1ToV2 dco_decode_cashu_v_1_to_v_2(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
                return CashuV1ToV2(tokens: dco_decode_list_String(arr[0]),
counters: dco_decode_String(arr[1]),
unavailableMints: dco_decode_Set_String_None(arr[2]),); }

@protected CommitResult dco_decode_commit_result(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
                return CommitResult(sender: dco_decode_String(arr[0]),
commitType: dco_decode_commit_type_result(arr[1]),
operatedMembers: dco_decode_opt_list_String(arr[2]),); }

@protected CommitTypeResult dco_decode_commit_type_result(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return CommitTypeResult.values[raw as int]; }

@protected ContactCashu dco_decode_contact_cashu(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return ContactCashu(method: dco_decode_String(arr[0]),
info: dco_decode_String(arr[1]),); }

@protected DecryptedMessage dco_decode_decrypted_message(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
                return DecryptedMessage(decryptMsg: dco_decode_String(arr[0]),
sender: dco_decode_String(arr[1]),
listenKey: dco_decode_String(arr[2]),); }

@protected GroupExtensionResult dco_decode_group_extension_result(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
                return GroupExtensionResult(name: dco_decode_list_prim_u_8_strict(arr[0]),
description: dco_decode_list_prim_u_8_strict(arr[1]),
adminPubkeys: dco_decode_list_list_prim_u_8_strict(arr[2]),
relays: dco_decode_list_list_prim_u_8_strict(arr[3]),
status: dco_decode_list_prim_u_8_strict(arr[4]),); }

@protected int dco_decode_i_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected InvoiceInfo dco_decode_invoice_info(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
                return InvoiceInfo(amount: dco_decode_u_64(arr[0]),
expiryTs: dco_decode_u_64(arr[1]),
hash: dco_decode_String(arr[2]),
memo: dco_decode_opt_String(arr[3]),
mint: dco_decode_opt_String(arr[4]),
status: dco_decode_invoice_status(arr[5]),); }

@protected InvoiceStatus dco_decode_invoice_status(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return InvoiceStatus.values[raw as int]; }

@protected KeyPackageResult dco_decode_key_package_result(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
                return KeyPackageResult(keyPackage: dco_decode_String(arr[0]),
mlsProtocolVersion: dco_decode_String(arr[1]),
ciphersuite: dco_decode_String(arr[2]),
extensions: dco_decode_String(arr[3]),); }

@protected KeychatIdentityKey dco_decode_keychat_identity_key(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
                return KeychatIdentityKey(publicKey: dco_decode_u_8_array_33(arr[0]),); }

@protected KeychatIdentityKeyPair dco_decode_keychat_identity_key_pair(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return KeychatIdentityKeyPair(identityKey: dco_decode_u_8_array_33(arr[0]),
privateKey: dco_decode_u_8_array_32(arr[1]),); }

@protected KeychatProtocolAddress dco_decode_keychat_protocol_address(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return KeychatProtocolAddress(name: dco_decode_String(arr[0]),
deviceId: dco_decode_u_32(arr[1]),); }

@protected KeychatSignalSession dco_decode_keychat_signal_session(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
                return KeychatSignalSession(aliceSenderRatchetKey: dco_decode_opt_String(arr[0]),
address: dco_decode_String(arr[1]),
device: dco_decode_u_32(arr[2]),
bobSenderRatchetKey: dco_decode_opt_String(arr[3]),
record: dco_decode_String(arr[4]),
bobAddress: dco_decode_opt_String(arr[5]),
aliceAddresses: dco_decode_opt_String(arr[6]),); }

@protected List<String> dco_decode_list_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_String).toList(); }

@protected List<ContactCashu> dco_decode_list_contact_cashu(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_contact_cashu).toList(); }

@protected List<List<String>> dco_decode_list_list_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_list_String).toList(); }

@protected List<Uint8List> dco_decode_list_list_prim_u_8_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_list_prim_u_8_strict).toList(); }

@protected List<MintCashu> dco_decode_list_mint_cashu(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_mint_cashu).toList(); }

@protected List<int> dco_decode_list_prim_u_8_loose(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as List<int>; }

@protected Uint8List dco_decode_list_prim_u_8_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as Uint8List; }

@protected List<(MintUrl,Amount)> dco_decode_list_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_mint_url_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_amount(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_mint_url_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_amount).toList(); }

@protected List<(String,bool)> dco_decode_list_record_string_bool(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_record_string_bool).toList(); }

@protected List<(String,List<Uint8List>)> dco_decode_list_record_string_list_list_prim_u_8_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_record_string_list_list_prim_u_8_strict).toList(); }

@protected List<(String,BigInt?)> dco_decode_list_record_string_opt_box_autoadd_u_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_record_string_opt_box_autoadd_u_64).toList(); }

@protected List<(String,String)> dco_decode_list_record_string_string(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_record_string_string).toList(); }

@protected List<Secp256k1Account> dco_decode_list_secp_256_k_1_account(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_secp_256_k_1_account).toList(); }

@protected List<Transaction> dco_decode_list_transaction(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return (raw as List<dynamic>).map(dco_decode_transaction).toList(); }

@protected MessageInType dco_decode_message_in_type(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return MessageInType.values[raw as int]; }

@protected MessageResult dco_decode_message_result(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return MessageResult(encryptMsg: dco_decode_String(arr[0]),
listenKey: dco_decode_String(arr[1]),); }

@protected MintCashu dco_decode_mint_cashu(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
                return MintCashu(url: dco_decode_String(arr[0]),
active: dco_decode_bool(arr[1]),
time: dco_decode_u_64(arr[2]),
info: dco_decode_opt_box_autoadd_mint_cashu_info(arr[3]),); }

@protected MintCashuInfo dco_decode_mint_cashu_info(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 8) throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
                return MintCashuInfo(name: dco_decode_String(arr[0]),
version: dco_decode_String(arr[1]),
pubkey: dco_decode_opt_String(arr[2]),
description: dco_decode_opt_String(arr[3]),
descriptionLong: dco_decode_opt_String(arr[4]),
motd: dco_decode_opt_String(arr[5]),
contact: dco_decode_list_contact_cashu(arr[6]),
nuts: dco_decode_Map_String_bool_None(arr[7]),); }

@protected NostrEvent dco_decode_nostr_event(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
                return NostrEvent(id: dco_decode_String(arr[0]),
pubkey: dco_decode_String(arr[1]),
createdAt: dco_decode_u_64(arr[2]),
kind: dco_decode_u_16(arr[3]),
tags: dco_decode_list_list_String(arr[4]),
content: dco_decode_String(arr[5]),
sig: dco_decode_String(arr[6]),); }

@protected String? dco_decode_opt_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_String(raw); }

@protected bool? dco_decode_opt_box_autoadd_bool(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_bool(raw); }

@protected KeychatIdentityKey? dco_decode_opt_box_autoadd_keychat_identity_key(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_keychat_identity_key(raw); }

@protected KeychatSignalSession? dco_decode_opt_box_autoadd_keychat_signal_session(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_keychat_signal_session(raw); }

@protected MintCashuInfo? dco_decode_opt_box_autoadd_mint_cashu_info(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_mint_cashu_info(raw); }

@protected int? dco_decode_opt_box_autoadd_u_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_u_32(raw); }

@protected BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_u_64(raw); }

@protected List<String>? dco_decode_opt_list_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_list_String(raw); }

@protected List<List<String>>? dco_decode_opt_list_list_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_list_list_String(raw); }

@protected Uint8List? dco_decode_opt_list_prim_u_8_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_list_prim_u_8_strict(raw); }

@protected (MintUrl,Amount) dco_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_mint_url_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_amount(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMintUrl(arr[0]),dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAmount(arr[1]),); }

@protected (Uint8List,Uint8List) dco_decode_record_list_prim_u_8_strict_list_prim_u_8_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_list_prim_u_8_strict(arr[0]),dco_decode_list_prim_u_8_strict(arr[1]),); }

@protected (Uint8List,String?,String,List<String>?) dco_decode_record_list_prim_u_8_strict_opt_string_string_opt_list_string(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 4) {
                throw Exception('Expected 4 elements, got ${arr.length}');
            }
            return (dco_decode_list_prim_u_8_strict(arr[0]),dco_decode_opt_String(arr[1]),dco_decode_String(arr[2]),dco_decode_opt_list_String(arr[3]),); }

@protected (Uint8List,String,List<String>?) dco_decode_record_list_prim_u_8_strict_string_opt_list_string(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 3) {
                throw Exception('Expected 3 elements, got ${arr.length}');
            }
            return (dco_decode_list_prim_u_8_strict(arr[0]),dco_decode_String(arr[1]),dco_decode_opt_list_String(arr[2]),); }

@protected (List<String>,Set<String>) dco_decode_record_list_string_set_string_none(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_list_String(arr[0]),dco_decode_Set_String_None(arr[1]),); }

@protected (List<String>,String,Set<String>) dco_decode_record_list_string_string_set_string_none(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 3) {
                throw Exception('Expected 3 elements, got ${arr.length}');
            }
            return (dco_decode_list_String(arr[0]),dco_decode_String(arr[1]),dco_decode_Set_String_None(arr[2]),); }

@protected (String,bool) dco_decode_record_string_bool(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_String(arr[0]),dco_decode_bool(arr[1]),); }

@protected (String,List<Uint8List>) dco_decode_record_string_list_list_prim_u_8_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_String(arr[0]),dco_decode_list_list_prim_u_8_strict(arr[1]),); }

@protected (String,BigInt?) dco_decode_record_string_opt_box_autoadd_u_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_String(arr[0]),dco_decode_opt_box_autoadd_u_64(arr[1]),); }

@protected (String,String) dco_decode_record_string_string(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_String(arr[0]),dco_decode_String(arr[1]),); }

@protected (String,int) dco_decode_record_string_u_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_String(arr[0]),dco_decode_u_32(arr[1]),); }

@protected (int,Uint8List,Uint8List) dco_decode_record_u_32_list_prim_u_8_strict_list_prim_u_8_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 3) {
                throw Exception('Expected 3 elements, got ${arr.length}');
            }
            return (dco_decode_u_32(arr[0]),dco_decode_list_prim_u_8_strict(arr[1]),dco_decode_list_prim_u_8_strict(arr[2]),); }

@protected (int,Uint8List,Uint8List,Uint8List) dco_decode_record_u_32_list_prim_u_8_strict_list_prim_u_8_strict_list_prim_u_8_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 4) {
                throw Exception('Expected 4 elements, got ${arr.length}');
            }
            return (dco_decode_u_32(arr[0]),dco_decode_list_prim_u_8_strict(arr[1]),dco_decode_list_prim_u_8_strict(arr[2]),dco_decode_list_prim_u_8_strict(arr[3]),); }

@protected (BigInt,BigInt) dco_decode_record_u_64_u_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 2) {
                throw Exception('Expected 2 elements, got ${arr.length}');
            }
            return (dco_decode_u_64(arr[0]),dco_decode_u_64(arr[1]),); }

@protected (BigInt,BigInt,BigInt) dco_decode_record_usize_usize_usize(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
            if (arr.length != 3) {
                throw Exception('Expected 3 elements, got ${arr.length}');
            }
            return (dco_decode_usize(arr[0]),dco_decode_usize(arr[1]),dco_decode_usize(arr[2]),); }

@protected Secp256k1Account dco_decode_secp_256_k_1_account(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 9) throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
                return Secp256k1Account(mnemonic: dco_decode_opt_String(arr[0]),
pubkey: dco_decode_String(arr[1]),
prikey: dco_decode_String(arr[2]),
pubkeyBech32: dco_decode_String(arr[3]),
prikeyBech32: dco_decode_String(arr[4]),
curve25519Sk: dco_decode_opt_list_prim_u_8_strict(arr[5]),
curve25519Pk: dco_decode_opt_list_prim_u_8_strict(arr[6]),
curve25519SkHex: dco_decode_opt_String(arr[7]),
curve25519PkHex: dco_decode_opt_String(arr[8]),); }

@protected Secp256k1SimpleAccount dco_decode_secp_256_k_1_simple_account(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return Secp256k1SimpleAccount(pubkey: dco_decode_String(arr[0]),
prikey: dco_decode_String(arr[1]),); }

@protected TokenInfo dco_decode_token_info(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
                return TokenInfo(mint: dco_decode_String(arr[0]),
amount: dco_decode_u_64(arr[1]),
unit: dco_decode_opt_String(arr[2]),
memo: dco_decode_opt_String(arr[3]),); }

@protected Transaction dco_decode_transaction(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 11) throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
                return Transaction(id: dco_decode_String(arr[0]),
mintUrl: dco_decode_String(arr[1]),
io: dco_decode_transaction_direction(arr[2]),
kind: dco_decode_transaction_kind(arr[3]),
amount: dco_decode_u_64(arr[4]),
fee: dco_decode_u_64(arr[5]),
unit: dco_decode_opt_String(arr[6]),
token: dco_decode_String(arr[7]),
status: dco_decode_transaction_status(arr[8]),
timestamp: dco_decode_u_64(arr[9]),
metadata: dco_decode_Map_String_String_None(arr[10]),); }

@protected TransactionDirection dco_decode_transaction_direction(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TransactionDirection.values[raw as int]; }

@protected TransactionKind dco_decode_transaction_kind(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TransactionKind.values[raw as int]; }

@protected TransactionStatus dco_decode_transaction_status(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return TransactionStatus.values[raw as int]; }

@protected int dco_decode_u_16(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected int dco_decode_u_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected BigInt dco_decode_u_64(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dcoDecodeU64(raw); }

@protected int dco_decode_u_8(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected U8Array32 dco_decode_u_8_array_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return U8Array32(dco_decode_list_prim_u_8_strict(raw)); }

@protected U8Array33 dco_decode_u_8_array_33(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return U8Array33(dco_decode_list_prim_u_8_strict(raw)); }

@protected void dco_decode_unit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return; }

@protected BigInt dco_decode_usize(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dcoDecodeU64(raw); }

@protected AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_String(deserializer);
        return AnyhowException(inner); }

@protected Amount sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAmount(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return AmountImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected CurrencyUnit sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCurrencyUnit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return CurrencyUnitImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected MintUrl sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMintUrl(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MintUrlImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected MnemonicInfo sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonicInfo(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MnemonicInfoImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Wallet sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWallet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WalletImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Mnemonic sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MnemonicImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected MnemonicInfo sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonicInfo(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MnemonicInfoImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected MultiMintWallet sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiMintWallet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MultiMintWalletImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Map<String, String> sse_decode_Map_String_String_None(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_record_string_string(deserializer);
        return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2))); }

@protected Map<String, bool> sse_decode_Map_String_bool_None(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_record_string_bool(deserializer);
        return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2))); }

@protected Map<String, List<Uint8List>> sse_decode_Map_String_list_list_prim_u_8_strict_None(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_record_string_list_list_prim_u_8_strict(deserializer);
        return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2))); }

@protected Map<String, BigInt?> sse_decode_Map_String_opt_box_autoadd_u_64_None(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_record_string_opt_box_autoadd_u_64(deserializer);
        return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2))); }

@protected Amount sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAmount(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return AmountImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected CurrencyUnit sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCurrencyUnit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return CurrencyUnitImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected MintUrl sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMintUrl(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MintUrlImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Mnemonic sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MnemonicImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected MnemonicInfo sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonicInfo(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MnemonicInfoImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected MultiMintWallet sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiMintWallet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return MultiMintWalletImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Wallet sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWallet(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return WalletImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected Set<String> sse_decode_Set_String_None(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_String(deserializer);
        return Set.from(inner); }

@protected String sse_decode_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_prim_u_8_strict(deserializer);
        return utf8.decoder.convert(inner); }

@protected AddMembersResult sse_decode_add_members_result(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_queuedMsg = sse_decode_String(deserializer);
var var_welcome = sse_decode_list_prim_u_8_strict(deserializer);
return AddMembersResult(queuedMsg: var_queuedMsg, welcome: var_welcome); }

@protected bool sse_decode_bool(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint8() != 0; }

@protected bool sse_decode_box_autoadd_bool(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_bool(deserializer)); }

@protected KeychatIdentityKey sse_decode_box_autoadd_keychat_identity_key(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_keychat_identity_key(deserializer)); }

@protected KeychatIdentityKeyPair sse_decode_box_autoadd_keychat_identity_key_pair(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_keychat_identity_key_pair(deserializer)); }

@protected KeychatProtocolAddress sse_decode_box_autoadd_keychat_protocol_address(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_keychat_protocol_address(deserializer)); }

@protected KeychatSignalSession sse_decode_box_autoadd_keychat_signal_session(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_keychat_signal_session(deserializer)); }

@protected MintCashuInfo sse_decode_box_autoadd_mint_cashu_info(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_mint_cashu_info(deserializer)); }

@protected int sse_decode_box_autoadd_u_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_u_32(deserializer)); }

@protected BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_u_64(deserializer)); }

@protected CashuV1ToV2 sse_decode_cashu_v_1_to_v_2(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_tokens = sse_decode_list_String(deserializer);
var var_counters = sse_decode_String(deserializer);
var var_unavailableMints = sse_decode_Set_String_None(deserializer);
return CashuV1ToV2(tokens: var_tokens, counters: var_counters, unavailableMints: var_unavailableMints); }

@protected CommitResult sse_decode_commit_result(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_sender = sse_decode_String(deserializer);
var var_commitType = sse_decode_commit_type_result(deserializer);
var var_operatedMembers = sse_decode_opt_list_String(deserializer);
return CommitResult(sender: var_sender, commitType: var_commitType, operatedMembers: var_operatedMembers); }

@protected CommitTypeResult sse_decode_commit_type_result(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return CommitTypeResult.values[inner]; }

@protected ContactCashu sse_decode_contact_cashu(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_method = sse_decode_String(deserializer);
var var_info = sse_decode_String(deserializer);
return ContactCashu(method: var_method, info: var_info); }

@protected DecryptedMessage sse_decode_decrypted_message(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_decryptMsg = sse_decode_String(deserializer);
var var_sender = sse_decode_String(deserializer);
var var_listenKey = sse_decode_String(deserializer);
return DecryptedMessage(decryptMsg: var_decryptMsg, sender: var_sender, listenKey: var_listenKey); }

@protected GroupExtensionResult sse_decode_group_extension_result(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_name = sse_decode_list_prim_u_8_strict(deserializer);
var var_description = sse_decode_list_prim_u_8_strict(deserializer);
var var_adminPubkeys = sse_decode_list_list_prim_u_8_strict(deserializer);
var var_relays = sse_decode_list_list_prim_u_8_strict(deserializer);
var var_status = sse_decode_list_prim_u_8_strict(deserializer);
return GroupExtensionResult(name: var_name, description: var_description, adminPubkeys: var_adminPubkeys, relays: var_relays, status: var_status); }

@protected int sse_decode_i_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getInt32(); }

@protected InvoiceInfo sse_decode_invoice_info(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_amount = sse_decode_u_64(deserializer);
var var_expiryTs = sse_decode_u_64(deserializer);
var var_hash = sse_decode_String(deserializer);
var var_memo = sse_decode_opt_String(deserializer);
var var_mint = sse_decode_opt_String(deserializer);
var var_status = sse_decode_invoice_status(deserializer);
return InvoiceInfo(amount: var_amount, expiryTs: var_expiryTs, hash: var_hash, memo: var_memo, mint: var_mint, status: var_status); }

@protected InvoiceStatus sse_decode_invoice_status(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return InvoiceStatus.values[inner]; }

@protected KeyPackageResult sse_decode_key_package_result(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_keyPackage = sse_decode_String(deserializer);
var var_mlsProtocolVersion = sse_decode_String(deserializer);
var var_ciphersuite = sse_decode_String(deserializer);
var var_extensions = sse_decode_String(deserializer);
return KeyPackageResult(keyPackage: var_keyPackage, mlsProtocolVersion: var_mlsProtocolVersion, ciphersuite: var_ciphersuite, extensions: var_extensions); }

@protected KeychatIdentityKey sse_decode_keychat_identity_key(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_publicKey = sse_decode_u_8_array_33(deserializer);
return KeychatIdentityKey(publicKey: var_publicKey); }

@protected KeychatIdentityKeyPair sse_decode_keychat_identity_key_pair(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_identityKey = sse_decode_u_8_array_33(deserializer);
var var_privateKey = sse_decode_u_8_array_32(deserializer);
return KeychatIdentityKeyPair(identityKey: var_identityKey, privateKey: var_privateKey); }

@protected KeychatProtocolAddress sse_decode_keychat_protocol_address(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_name = sse_decode_String(deserializer);
var var_deviceId = sse_decode_u_32(deserializer);
return KeychatProtocolAddress(name: var_name, deviceId: var_deviceId); }

@protected KeychatSignalSession sse_decode_keychat_signal_session(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_aliceSenderRatchetKey = sse_decode_opt_String(deserializer);
var var_address = sse_decode_String(deserializer);
var var_device = sse_decode_u_32(deserializer);
var var_bobSenderRatchetKey = sse_decode_opt_String(deserializer);
var var_record = sse_decode_String(deserializer);
var var_bobAddress = sse_decode_opt_String(deserializer);
var var_aliceAddresses = sse_decode_opt_String(deserializer);
return KeychatSignalSession(aliceSenderRatchetKey: var_aliceSenderRatchetKey, address: var_address, device: var_device, bobSenderRatchetKey: var_bobSenderRatchetKey, record: var_record, bobAddress: var_bobAddress, aliceAddresses: var_aliceAddresses); }

@protected List<String> sse_decode_list_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <String>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_String(deserializer)); }
        return ans_;
         }

@protected List<ContactCashu> sse_decode_list_contact_cashu(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <ContactCashu>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_contact_cashu(deserializer)); }
        return ans_;
         }

@protected List<List<String>> sse_decode_list_list_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <List<String>>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_list_String(deserializer)); }
        return ans_;
         }

@protected List<Uint8List> sse_decode_list_list_prim_u_8_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <Uint8List>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_list_prim_u_8_strict(deserializer)); }
        return ans_;
         }

@protected List<MintCashu> sse_decode_list_mint_cashu(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <MintCashu>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_mint_cashu(deserializer)); }
        return ans_;
         }

@protected List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var len_ = sse_decode_i_32(deserializer);
                return deserializer.buffer.getUint8List(len_); }

@protected Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var len_ = sse_decode_i_32(deserializer);
                return deserializer.buffer.getUint8List(len_); }

@protected List<(MintUrl,Amount)> sse_decode_list_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_mint_url_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_amount(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <(MintUrl,Amount)>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_mint_url_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_amount(deserializer)); }
        return ans_;
         }

@protected List<(String,bool)> sse_decode_list_record_string_bool(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <(String,bool)>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_record_string_bool(deserializer)); }
        return ans_;
         }

@protected List<(String,List<Uint8List>)> sse_decode_list_record_string_list_list_prim_u_8_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <(String,List<Uint8List>)>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_record_string_list_list_prim_u_8_strict(deserializer)); }
        return ans_;
         }

@protected List<(String,BigInt?)> sse_decode_list_record_string_opt_box_autoadd_u_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <(String,BigInt?)>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_record_string_opt_box_autoadd_u_64(deserializer)); }
        return ans_;
         }

@protected List<(String,String)> sse_decode_list_record_string_string(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <(String,String)>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_record_string_string(deserializer)); }
        return ans_;
         }

@protected List<Secp256k1Account> sse_decode_list_secp_256_k_1_account(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <Secp256k1Account>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_secp_256_k_1_account(deserializer)); }
        return ans_;
         }

@protected List<Transaction> sse_decode_list_transaction(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

        var len_ = sse_decode_i_32(deserializer);
        var ans_ = <Transaction>[];
        for (var idx_ = 0; idx_ < len_; ++idx_) { ans_.add(sse_decode_transaction(deserializer)); }
        return ans_;
         }

@protected MessageInType sse_decode_message_in_type(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return MessageInType.values[inner]; }

@protected MessageResult sse_decode_message_result(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_encryptMsg = sse_decode_String(deserializer);
var var_listenKey = sse_decode_String(deserializer);
return MessageResult(encryptMsg: var_encryptMsg, listenKey: var_listenKey); }

@protected MintCashu sse_decode_mint_cashu(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_url = sse_decode_String(deserializer);
var var_active = sse_decode_bool(deserializer);
var var_time = sse_decode_u_64(deserializer);
var var_info = sse_decode_opt_box_autoadd_mint_cashu_info(deserializer);
return MintCashu(url: var_url, active: var_active, time: var_time, info: var_info); }

@protected MintCashuInfo sse_decode_mint_cashu_info(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_name = sse_decode_String(deserializer);
var var_version = sse_decode_String(deserializer);
var var_pubkey = sse_decode_opt_String(deserializer);
var var_description = sse_decode_opt_String(deserializer);
var var_descriptionLong = sse_decode_opt_String(deserializer);
var var_motd = sse_decode_opt_String(deserializer);
var var_contact = sse_decode_list_contact_cashu(deserializer);
var var_nuts = sse_decode_Map_String_bool_None(deserializer);
return MintCashuInfo(name: var_name, version: var_version, pubkey: var_pubkey, description: var_description, descriptionLong: var_descriptionLong, motd: var_motd, contact: var_contact, nuts: var_nuts); }

@protected NostrEvent sse_decode_nostr_event(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_id = sse_decode_String(deserializer);
var var_pubkey = sse_decode_String(deserializer);
var var_createdAt = sse_decode_u_64(deserializer);
var var_kind = sse_decode_u_16(deserializer);
var var_tags = sse_decode_list_list_String(deserializer);
var var_content = sse_decode_String(deserializer);
var var_sig = sse_decode_String(deserializer);
return NostrEvent(id: var_id, pubkey: var_pubkey, createdAt: var_createdAt, kind: var_kind, tags: var_tags, content: var_content, sig: var_sig); }

@protected String? sse_decode_opt_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_String(deserializer));
            } else {
                return null;
            }
             }

@protected bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_bool(deserializer));
            } else {
                return null;
            }
             }

@protected KeychatIdentityKey? sse_decode_opt_box_autoadd_keychat_identity_key(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_keychat_identity_key(deserializer));
            } else {
                return null;
            }
             }

@protected KeychatSignalSession? sse_decode_opt_box_autoadd_keychat_signal_session(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_keychat_signal_session(deserializer));
            } else {
                return null;
            }
             }

@protected MintCashuInfo? sse_decode_opt_box_autoadd_mint_cashu_info(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_mint_cashu_info(deserializer));
            } else {
                return null;
            }
             }

@protected int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_u_32(deserializer));
            } else {
                return null;
            }
             }

@protected BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_u_64(deserializer));
            } else {
                return null;
            }
             }

@protected List<String>? sse_decode_opt_list_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_list_String(deserializer));
            } else {
                return null;
            }
             }

@protected List<List<String>>? sse_decode_opt_list_list_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_list_list_String(deserializer));
            } else {
                return null;
            }
             }

@protected Uint8List? sse_decode_opt_list_prim_u_8_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_list_prim_u_8_strict(deserializer));
            } else {
                return null;
            }
             }

@protected (MintUrl,Amount) sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_mint_url_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_amount(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMintUrl(deserializer);
var var_field1 = sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAmount(deserializer);
return (var_field0, var_field1); }

@protected (Uint8List,Uint8List) sse_decode_record_list_prim_u_8_strict_list_prim_u_8_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_list_prim_u_8_strict(deserializer);
var var_field1 = sse_decode_list_prim_u_8_strict(deserializer);
return (var_field0, var_field1); }

@protected (Uint8List,String?,String,List<String>?) sse_decode_record_list_prim_u_8_strict_opt_string_string_opt_list_string(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_list_prim_u_8_strict(deserializer);
var var_field1 = sse_decode_opt_String(deserializer);
var var_field2 = sse_decode_String(deserializer);
var var_field3 = sse_decode_opt_list_String(deserializer);
return (var_field0, var_field1, var_field2, var_field3); }

@protected (Uint8List,String,List<String>?) sse_decode_record_list_prim_u_8_strict_string_opt_list_string(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_list_prim_u_8_strict(deserializer);
var var_field1 = sse_decode_String(deserializer);
var var_field2 = sse_decode_opt_list_String(deserializer);
return (var_field0, var_field1, var_field2); }

@protected (List<String>,Set<String>) sse_decode_record_list_string_set_string_none(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_list_String(deserializer);
var var_field1 = sse_decode_Set_String_None(deserializer);
return (var_field0, var_field1); }

@protected (List<String>,String,Set<String>) sse_decode_record_list_string_string_set_string_none(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_list_String(deserializer);
var var_field1 = sse_decode_String(deserializer);
var var_field2 = sse_decode_Set_String_None(deserializer);
return (var_field0, var_field1, var_field2); }

@protected (String,bool) sse_decode_record_string_bool(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_String(deserializer);
var var_field1 = sse_decode_bool(deserializer);
return (var_field0, var_field1); }

@protected (String,List<Uint8List>) sse_decode_record_string_list_list_prim_u_8_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_String(deserializer);
var var_field1 = sse_decode_list_list_prim_u_8_strict(deserializer);
return (var_field0, var_field1); }

@protected (String,BigInt?) sse_decode_record_string_opt_box_autoadd_u_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_String(deserializer);
var var_field1 = sse_decode_opt_box_autoadd_u_64(deserializer);
return (var_field0, var_field1); }

@protected (String,String) sse_decode_record_string_string(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_String(deserializer);
var var_field1 = sse_decode_String(deserializer);
return (var_field0, var_field1); }

@protected (String,int) sse_decode_record_string_u_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_String(deserializer);
var var_field1 = sse_decode_u_32(deserializer);
return (var_field0, var_field1); }

@protected (int,Uint8List,Uint8List) sse_decode_record_u_32_list_prim_u_8_strict_list_prim_u_8_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_u_32(deserializer);
var var_field1 = sse_decode_list_prim_u_8_strict(deserializer);
var var_field2 = sse_decode_list_prim_u_8_strict(deserializer);
return (var_field0, var_field1, var_field2); }

@protected (int,Uint8List,Uint8List,Uint8List) sse_decode_record_u_32_list_prim_u_8_strict_list_prim_u_8_strict_list_prim_u_8_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_u_32(deserializer);
var var_field1 = sse_decode_list_prim_u_8_strict(deserializer);
var var_field2 = sse_decode_list_prim_u_8_strict(deserializer);
var var_field3 = sse_decode_list_prim_u_8_strict(deserializer);
return (var_field0, var_field1, var_field2, var_field3); }

@protected (BigInt,BigInt) sse_decode_record_u_64_u_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_u_64(deserializer);
var var_field1 = sse_decode_u_64(deserializer);
return (var_field0, var_field1); }

@protected (BigInt,BigInt,BigInt) sse_decode_record_usize_usize_usize(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_field0 = sse_decode_usize(deserializer);
var var_field1 = sse_decode_usize(deserializer);
var var_field2 = sse_decode_usize(deserializer);
return (var_field0, var_field1, var_field2); }

@protected Secp256k1Account sse_decode_secp_256_k_1_account(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_mnemonic = sse_decode_opt_String(deserializer);
var var_pubkey = sse_decode_String(deserializer);
var var_prikey = sse_decode_String(deserializer);
var var_pubkeyBech32 = sse_decode_String(deserializer);
var var_prikeyBech32 = sse_decode_String(deserializer);
var var_curve25519Sk = sse_decode_opt_list_prim_u_8_strict(deserializer);
var var_curve25519Pk = sse_decode_opt_list_prim_u_8_strict(deserializer);
var var_curve25519SkHex = sse_decode_opt_String(deserializer);
var var_curve25519PkHex = sse_decode_opt_String(deserializer);
return Secp256k1Account(mnemonic: var_mnemonic, pubkey: var_pubkey, prikey: var_prikey, pubkeyBech32: var_pubkeyBech32, prikeyBech32: var_prikeyBech32, curve25519Sk: var_curve25519Sk, curve25519Pk: var_curve25519Pk, curve25519SkHex: var_curve25519SkHex, curve25519PkHex: var_curve25519PkHex); }

@protected Secp256k1SimpleAccount sse_decode_secp_256_k_1_simple_account(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_pubkey = sse_decode_String(deserializer);
var var_prikey = sse_decode_String(deserializer);
return Secp256k1SimpleAccount(pubkey: var_pubkey, prikey: var_prikey); }

@protected TokenInfo sse_decode_token_info(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_mint = sse_decode_String(deserializer);
var var_amount = sse_decode_u_64(deserializer);
var var_unit = sse_decode_opt_String(deserializer);
var var_memo = sse_decode_opt_String(deserializer);
return TokenInfo(mint: var_mint, amount: var_amount, unit: var_unit, memo: var_memo); }

@protected Transaction sse_decode_transaction(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_id = sse_decode_String(deserializer);
var var_mintUrl = sse_decode_String(deserializer);
var var_io = sse_decode_transaction_direction(deserializer);
var var_kind = sse_decode_transaction_kind(deserializer);
var var_amount = sse_decode_u_64(deserializer);
var var_fee = sse_decode_u_64(deserializer);
var var_unit = sse_decode_opt_String(deserializer);
var var_token = sse_decode_String(deserializer);
var var_status = sse_decode_transaction_status(deserializer);
var var_timestamp = sse_decode_u_64(deserializer);
var var_metadata = sse_decode_Map_String_String_None(deserializer);
return Transaction(id: var_id, mintUrl: var_mintUrl, io: var_io, kind: var_kind, amount: var_amount, fee: var_fee, unit: var_unit, token: var_token, status: var_status, timestamp: var_timestamp, metadata: var_metadata); }

@protected TransactionDirection sse_decode_transaction_direction(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return TransactionDirection.values[inner]; }

@protected TransactionKind sse_decode_transaction_kind(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return TransactionKind.values[inner]; }

@protected TransactionStatus sse_decode_transaction_status(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_i_32(deserializer);
        return TransactionStatus.values[inner]; }

@protected int sse_decode_u_16(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint16(); }

@protected int sse_decode_u_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint32(); }

@protected BigInt sse_decode_u_64(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getBigUint64(); }

@protected int sse_decode_u_8(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint8(); }

@protected U8Array32 sse_decode_u_8_array_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_prim_u_8_strict(deserializer);
        return U8Array32(inner); }

@protected U8Array33 sse_decode_u_8_array_33(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_prim_u_8_strict(deserializer);
        return U8Array33(inner); }

@protected void sse_decode_unit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
 }

@protected BigInt sse_decode_usize(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getBigUint64(); }

@protected void sse_encode_AnyhowException(AnyhowException self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.message, serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAmount(Amount self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as AmountImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCurrencyUnit(CurrencyUnit self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as CurrencyUnitImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMintUrl(MintUrl self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MintUrlImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonicInfo(MnemonicInfo self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MnemonicInfoImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWallet(Wallet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WalletImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(Mnemonic self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MnemonicImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonicInfo(MnemonicInfo self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MnemonicInfoImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiMintWallet(MultiMintWallet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MultiMintWalletImpl).frbInternalSseEncode(move: false), serializer); }

@protected void sse_encode_Map_String_String_None(Map<String, String> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_record_string_string(self.entries.map((e) => (e.key, e.value)).toList(), serializer); }

@protected void sse_encode_Map_String_bool_None(Map<String, bool> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_record_string_bool(self.entries.map((e) => (e.key, e.value)).toList(), serializer); }

@protected void sse_encode_Map_String_list_list_prim_u_8_strict_None(Map<String, List<Uint8List>> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_record_string_list_list_prim_u_8_strict(self.entries.map((e) => (e.key, e.value)).toList(), serializer); }

@protected void sse_encode_Map_String_opt_box_autoadd_u_64_None(Map<String, BigInt?> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_record_string_opt_box_autoadd_u_64(self.entries.map((e) => (e.key, e.value)).toList(), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAmount(Amount self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as AmountImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCurrencyUnit(CurrencyUnit self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as CurrencyUnitImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMintUrl(MintUrl self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MintUrlImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonic(Mnemonic self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MnemonicImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMnemonicInfo(MnemonicInfo self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MnemonicInfoImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiMintWallet(MultiMintWallet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as MultiMintWalletImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWallet(Wallet self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as WalletImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_Set_String_None(Set<String> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_String(self.toList(), serializer); }

@protected void sse_encode_String(String self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer); }

@protected void sse_encode_add_members_result(AddMembersResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.queuedMsg, serializer);
sse_encode_list_prim_u_8_strict(self.welcome, serializer);
 }

@protected void sse_encode_bool(bool self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint8(self ? 1 : 0); }

@protected void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_bool(self, serializer); }

@protected void sse_encode_box_autoadd_keychat_identity_key(KeychatIdentityKey self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_keychat_identity_key(self, serializer); }

@protected void sse_encode_box_autoadd_keychat_identity_key_pair(KeychatIdentityKeyPair self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_keychat_identity_key_pair(self, serializer); }

@protected void sse_encode_box_autoadd_keychat_protocol_address(KeychatProtocolAddress self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_keychat_protocol_address(self, serializer); }

@protected void sse_encode_box_autoadd_keychat_signal_session(KeychatSignalSession self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_keychat_signal_session(self, serializer); }

@protected void sse_encode_box_autoadd_mint_cashu_info(MintCashuInfo self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_mint_cashu_info(self, serializer); }

@protected void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_32(self, serializer); }

@protected void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_64(self, serializer); }

@protected void sse_encode_cashu_v_1_to_v_2(CashuV1ToV2 self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_String(self.tokens, serializer);
sse_encode_String(self.counters, serializer);
sse_encode_Set_String_None(self.unavailableMints, serializer);
 }

@protected void sse_encode_commit_result(CommitResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.sender, serializer);
sse_encode_commit_type_result(self.commitType, serializer);
sse_encode_opt_list_String(self.operatedMembers, serializer);
 }

@protected void sse_encode_commit_type_result(CommitTypeResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_contact_cashu(ContactCashu self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.method, serializer);
sse_encode_String(self.info, serializer);
 }

@protected void sse_encode_decrypted_message(DecryptedMessage self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.decryptMsg, serializer);
sse_encode_String(self.sender, serializer);
sse_encode_String(self.listenKey, serializer);
 }

@protected void sse_encode_group_extension_result(GroupExtensionResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_prim_u_8_strict(self.name, serializer);
sse_encode_list_prim_u_8_strict(self.description, serializer);
sse_encode_list_list_prim_u_8_strict(self.adminPubkeys, serializer);
sse_encode_list_list_prim_u_8_strict(self.relays, serializer);
sse_encode_list_prim_u_8_strict(self.status, serializer);
 }

@protected void sse_encode_i_32(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putInt32(self); }

@protected void sse_encode_invoice_info(InvoiceInfo self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_64(self.amount, serializer);
sse_encode_u_64(self.expiryTs, serializer);
sse_encode_String(self.hash, serializer);
sse_encode_opt_String(self.memo, serializer);
sse_encode_opt_String(self.mint, serializer);
sse_encode_invoice_status(self.status, serializer);
 }

@protected void sse_encode_invoice_status(InvoiceStatus self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_key_package_result(KeyPackageResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.keyPackage, serializer);
sse_encode_String(self.mlsProtocolVersion, serializer);
sse_encode_String(self.ciphersuite, serializer);
sse_encode_String(self.extensions, serializer);
 }

@protected void sse_encode_keychat_identity_key(KeychatIdentityKey self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_8_array_33(self.publicKey, serializer);
 }

@protected void sse_encode_keychat_identity_key_pair(KeychatIdentityKeyPair self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_8_array_33(self.identityKey, serializer);
sse_encode_u_8_array_32(self.privateKey, serializer);
 }

@protected void sse_encode_keychat_protocol_address(KeychatProtocolAddress self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.name, serializer);
sse_encode_u_32(self.deviceId, serializer);
 }

@protected void sse_encode_keychat_signal_session(KeychatSignalSession self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_opt_String(self.aliceSenderRatchetKey, serializer);
sse_encode_String(self.address, serializer);
sse_encode_u_32(self.device, serializer);
sse_encode_opt_String(self.bobSenderRatchetKey, serializer);
sse_encode_String(self.record, serializer);
sse_encode_opt_String(self.bobAddress, serializer);
sse_encode_opt_String(self.aliceAddresses, serializer);
 }

@protected void sse_encode_list_String(List<String> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_String(item, serializer); } }

@protected void sse_encode_list_contact_cashu(List<ContactCashu> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_contact_cashu(item, serializer); } }

@protected void sse_encode_list_list_String(List<List<String>> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_list_String(item, serializer); } }

@protected void sse_encode_list_list_prim_u_8_strict(List<Uint8List> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_list_prim_u_8_strict(item, serializer); } }

@protected void sse_encode_list_mint_cashu(List<MintCashu> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_mint_cashu(item, serializer); } }

@protected void sse_encode_list_prim_u_8_loose(List<int> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
                    serializer.buffer.putUint8List(self is Uint8List ? self : Uint8List.fromList(self)); }

@protected void sse_encode_list_prim_u_8_strict(Uint8List self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
                    serializer.buffer.putUint8List(self); }

@protected void sse_encode_list_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_mint_url_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_amount(List<(MintUrl,Amount)> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_mint_url_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_amount(item, serializer); } }

@protected void sse_encode_list_record_string_bool(List<(String,bool)> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_record_string_bool(item, serializer); } }

@protected void sse_encode_list_record_string_list_list_prim_u_8_strict(List<(String,List<Uint8List>)> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_record_string_list_list_prim_u_8_strict(item, serializer); } }

@protected void sse_encode_list_record_string_opt_box_autoadd_u_64(List<(String,BigInt?)> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_record_string_opt_box_autoadd_u_64(item, serializer); } }

@protected void sse_encode_list_record_string_string(List<(String,String)> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_record_string_string(item, serializer); } }

@protected void sse_encode_list_secp_256_k_1_account(List<Secp256k1Account> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_secp_256_k_1_account(item, serializer); } }

@protected void sse_encode_list_transaction(List<Transaction> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
        for (final item in self) { sse_encode_transaction(item, serializer); } }

@protected void sse_encode_message_in_type(MessageInType self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_message_result(MessageResult self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.encryptMsg, serializer);
sse_encode_String(self.listenKey, serializer);
 }

@protected void sse_encode_mint_cashu(MintCashu self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.url, serializer);
sse_encode_bool(self.active, serializer);
sse_encode_u_64(self.time, serializer);
sse_encode_opt_box_autoadd_mint_cashu_info(self.info, serializer);
 }

@protected void sse_encode_mint_cashu_info(MintCashuInfo self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.name, serializer);
sse_encode_String(self.version, serializer);
sse_encode_opt_String(self.pubkey, serializer);
sse_encode_opt_String(self.description, serializer);
sse_encode_opt_String(self.descriptionLong, serializer);
sse_encode_opt_String(self.motd, serializer);
sse_encode_list_contact_cashu(self.contact, serializer);
sse_encode_Map_String_bool_None(self.nuts, serializer);
 }

@protected void sse_encode_nostr_event(NostrEvent self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.id, serializer);
sse_encode_String(self.pubkey, serializer);
sse_encode_u_64(self.createdAt, serializer);
sse_encode_u_16(self.kind, serializer);
sse_encode_list_list_String(self.tags, serializer);
sse_encode_String(self.content, serializer);
sse_encode_String(self.sig, serializer);
 }

@protected void sse_encode_opt_String(String? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_String(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_bool(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_keychat_identity_key(KeychatIdentityKey? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_keychat_identity_key(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_keychat_signal_session(KeychatSignalSession? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_keychat_signal_session(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_mint_cashu_info(MintCashuInfo? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_mint_cashu_info(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_u_32(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_u_64(self, serializer);
                }
                 }

@protected void sse_encode_opt_list_String(List<String>? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_list_String(self, serializer);
                }
                 }

@protected void sse_encode_opt_list_list_String(List<List<String>>? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_list_list_String(self, serializer);
                }
                 }

@protected void sse_encode_opt_list_prim_u_8_strict(Uint8List? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_list_prim_u_8_strict(self, serializer);
                }
                 }

@protected void sse_encode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_mint_url_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_amount((MintUrl,Amount) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMintUrl(self.$1, serializer);
sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAmount(self.$2, serializer);
 }

@protected void sse_encode_record_list_prim_u_8_strict_list_prim_u_8_strict((Uint8List,Uint8List) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_prim_u_8_strict(self.$1, serializer);
sse_encode_list_prim_u_8_strict(self.$2, serializer);
 }

@protected void sse_encode_record_list_prim_u_8_strict_opt_string_string_opt_list_string((Uint8List,String?,String,List<String>?) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_prim_u_8_strict(self.$1, serializer);
sse_encode_opt_String(self.$2, serializer);
sse_encode_String(self.$3, serializer);
sse_encode_opt_list_String(self.$4, serializer);
 }

@protected void sse_encode_record_list_prim_u_8_strict_string_opt_list_string((Uint8List,String,List<String>?) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_prim_u_8_strict(self.$1, serializer);
sse_encode_String(self.$2, serializer);
sse_encode_opt_list_String(self.$3, serializer);
 }

@protected void sse_encode_record_list_string_set_string_none((List<String>,Set<String>) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_String(self.$1, serializer);
sse_encode_Set_String_None(self.$2, serializer);
 }

@protected void sse_encode_record_list_string_string_set_string_none((List<String>,String,Set<String>) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_String(self.$1, serializer);
sse_encode_String(self.$2, serializer);
sse_encode_Set_String_None(self.$3, serializer);
 }

@protected void sse_encode_record_string_bool((String,bool) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.$1, serializer);
sse_encode_bool(self.$2, serializer);
 }

@protected void sse_encode_record_string_list_list_prim_u_8_strict((String,List<Uint8List>) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.$1, serializer);
sse_encode_list_list_prim_u_8_strict(self.$2, serializer);
 }

@protected void sse_encode_record_string_opt_box_autoadd_u_64((String,BigInt?) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.$1, serializer);
sse_encode_opt_box_autoadd_u_64(self.$2, serializer);
 }

@protected void sse_encode_record_string_string((String,String) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.$1, serializer);
sse_encode_String(self.$2, serializer);
 }

@protected void sse_encode_record_string_u_32((String,int) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.$1, serializer);
sse_encode_u_32(self.$2, serializer);
 }

@protected void sse_encode_record_u_32_list_prim_u_8_strict_list_prim_u_8_strict((int,Uint8List,Uint8List) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_32(self.$1, serializer);
sse_encode_list_prim_u_8_strict(self.$2, serializer);
sse_encode_list_prim_u_8_strict(self.$3, serializer);
 }

@protected void sse_encode_record_u_32_list_prim_u_8_strict_list_prim_u_8_strict_list_prim_u_8_strict((int,Uint8List,Uint8List,Uint8List) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_32(self.$1, serializer);
sse_encode_list_prim_u_8_strict(self.$2, serializer);
sse_encode_list_prim_u_8_strict(self.$3, serializer);
sse_encode_list_prim_u_8_strict(self.$4, serializer);
 }

@protected void sse_encode_record_u_64_u_64((BigInt,BigInt) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_64(self.$1, serializer);
sse_encode_u_64(self.$2, serializer);
 }

@protected void sse_encode_record_usize_usize_usize((BigInt,BigInt,BigInt) self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize(self.$1, serializer);
sse_encode_usize(self.$2, serializer);
sse_encode_usize(self.$3, serializer);
 }

@protected void sse_encode_secp_256_k_1_account(Secp256k1Account self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_opt_String(self.mnemonic, serializer);
sse_encode_String(self.pubkey, serializer);
sse_encode_String(self.prikey, serializer);
sse_encode_String(self.pubkeyBech32, serializer);
sse_encode_String(self.prikeyBech32, serializer);
sse_encode_opt_list_prim_u_8_strict(self.curve25519Sk, serializer);
sse_encode_opt_list_prim_u_8_strict(self.curve25519Pk, serializer);
sse_encode_opt_String(self.curve25519SkHex, serializer);
sse_encode_opt_String(self.curve25519PkHex, serializer);
 }

@protected void sse_encode_secp_256_k_1_simple_account(Secp256k1SimpleAccount self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.pubkey, serializer);
sse_encode_String(self.prikey, serializer);
 }

@protected void sse_encode_token_info(TokenInfo self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.mint, serializer);
sse_encode_u_64(self.amount, serializer);
sse_encode_opt_String(self.unit, serializer);
sse_encode_opt_String(self.memo, serializer);
 }

@protected void sse_encode_transaction(Transaction self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.id, serializer);
sse_encode_String(self.mintUrl, serializer);
sse_encode_transaction_direction(self.io, serializer);
sse_encode_transaction_kind(self.kind, serializer);
sse_encode_u_64(self.amount, serializer);
sse_encode_u_64(self.fee, serializer);
sse_encode_opt_String(self.unit, serializer);
sse_encode_String(self.token, serializer);
sse_encode_transaction_status(self.status, serializer);
sse_encode_u_64(self.timestamp, serializer);
sse_encode_Map_String_String_None(self.metadata, serializer);
 }

@protected void sse_encode_transaction_direction(TransactionDirection self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_transaction_kind(TransactionKind self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_transaction_status(TransactionStatus self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.index, serializer); }

@protected void sse_encode_u_16(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint16(self); }

@protected void sse_encode_u_32(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint32(self); }

@protected void sse_encode_u_64(BigInt self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putBigUint64(self); }

@protected void sse_encode_u_8(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint8(self); }

@protected void sse_encode_u_8_array_32(U8Array32 self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_prim_u_8_strict(self.inner, serializer); }

@protected void sse_encode_u_8_array_33(U8Array33 self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_prim_u_8_strict(self.inner, serializer); }

@protected void sse_encode_unit(void self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
 }

@protected void sse_encode_usize(BigInt self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putBigUint64(self); }
                }
                

            @sealed class AmountImpl extends RustOpaque implements Amount {
                // Not to be used by end users
                AmountImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                AmountImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Amount,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Amount,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_AmountPtr,
                );

                
            }
            @sealed class CurrencyUnitImpl extends RustOpaque implements CurrencyUnit {
                // Not to be used by end users
                CurrencyUnitImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                CurrencyUnitImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_CurrencyUnit,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_CurrencyUnit,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_CurrencyUnitPtr,
                );

                
            }
            @sealed class MintUrlImpl extends RustOpaque implements MintUrl {
                // Not to be used by end users
                MintUrlImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                MintUrlImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_MintUrl,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_MintUrl,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_MintUrlPtr,
                );

                
            }
            @sealed class MnemonicImpl extends RustOpaque implements Mnemonic {
                // Not to be used by end users
                MnemonicImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                MnemonicImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Mnemonic,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Mnemonic,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_MnemonicPtr,
                );

                
            }
            @sealed class MnemonicInfoImpl extends RustOpaque implements MnemonicInfo {
                // Not to be used by end users
                MnemonicInfoImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                MnemonicInfoImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_MnemonicInfo,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_MnemonicInfo,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_MnemonicInfoPtr,
                );

                 Future<void>  mnemonic()=>RustLib.instance.api.crateApiCashuTypesMnemonicInfoMnemonic(that: this, );


 Future<void>  pubkey()=>RustLib.instance.api.crateApiCashuTypesMnemonicInfoPubkey(that: this, );


            }
            @sealed class MultiMintWalletImpl extends RustOpaque implements MultiMintWallet {
                // Not to be used by end users
                MultiMintWalletImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                MultiMintWalletImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_MultiMintWallet,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_MultiMintWallet,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_MultiMintWalletPtr,
                );

                
            }
            @sealed class WalletImpl extends RustOpaque implements Wallet {
                // Not to be used by end users
                WalletImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                WalletImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: RustLib.instance.api.rust_arc_increment_strong_count_Wallet,
                    rustArcDecrementStrongCount: RustLib.instance.api.rust_arc_decrement_strong_count_Wallet,
                    rustArcDecrementStrongCountPtr: RustLib.instance.api.rust_arc_decrement_strong_count_WalletPtr,
                );

                
            }