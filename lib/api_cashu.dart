// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'api_cashu/types.dart';
import 'frb_generated.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';


            // These functions are ignored because they are not marked as `pub`: `_send`, `check_sufficient_funds`, `get_or_create_wallet`, `get_wallet_by_mint_url`, `mint_balances`, `new`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `STATE`, `State`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `deref`, `fmt`, `fmt`, `fmt`, `initialize`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `get_mnemonic_info`, `get_wallet`, `get_wallet`, `lock`, `mnemonic`, `update_mnmonic`


            Future<void>  initDb({required String dbpath , required String words , required bool dev }) => RustLib.instance.api.crateApiCashuInitDb(dbpath: dbpath, words: words, dev: dev);

Future<List<String>>  initCashu({required int prepareSatsOnceTime }) => RustLib.instance.api.crateApiCashuInitCashu(prepareSatsOnceTime: prepareSatsOnceTime);

Future<bool>  setMnemonic({String? words }) => RustLib.instance.api.crateApiCashuSetMnemonic(words: words);

Future<Map<String, void>>  getMints() => RustLib.instance.api.crateApiCashuGetMints();

Future<void>  addMint({required String url }) => RustLib.instance.api.crateApiCashuAddMint(url: url);

Future<void>  removeMint({required String url }) => RustLib.instance.api.crateApiCashuRemoveMint(url: url);

Future<String>  getBalances() => RustLib.instance.api.crateApiCashuGetBalances();

Future<Transaction>  sendAll({required String mint }) => RustLib.instance.api.crateApiCashuSendAll(mint: mint);

/// default set 20
Future<void>  mergeProofs({required BigInt thershold }) => RustLib.instance.api.crateApiCashuMergeProofs(thershold: thershold);

/// inner used, this is for receive stamps every multi times
/// need diff mint url put in a like map<url, token>
Future<void>  multiReceive({required List<String> stamps }) => RustLib.instance.api.crateApiCashuMultiReceive(stamps: stamps);

Future<Transaction>  receiveToken({required String encodedToken }) => RustLib.instance.api.crateApiCashuReceiveToken(encodedToken: encodedToken);

/// inner used
Future<void>  printProofs({required String mint }) => RustLib.instance.api.crateApiCashuPrintProofs(mint: mint);

Future<BigInt>  prepareOneProofs({required BigInt amount , required String mint }) => RustLib.instance.api.crateApiCashuPrepareOneProofs(amount: amount, mint: mint);

Future<Transaction>  sendStamp({required BigInt amount , required List<String> mints , String? info }) => RustLib.instance.api.crateApiCashuSendStamp(amount: amount, mints: mints, info: info);

/// Helper function to get a wallet from the multi-mint wallet
Future<Wallet>  getWalletByIndex({required MultiMintWallet multiMintWallet , required List<(MintUrl,Amount)> mintAmounts , required BigInt mintNumber , required CurrencyUnit unit }) => RustLib.instance.api.crateApiCashuGetWalletByIndex(multiMintWallet: multiMintWallet, mintAmounts: mintAmounts, mintNumber: mintNumber, unit: unit);

/// Helper function to validate a mint number against available mints
Future<void>  validateMintNumber({required BigInt mintNumber , required BigInt mintCount }) => RustLib.instance.api.crateApiCashuValidateMintNumber(mintNumber: mintNumber, mintCount: mintCount);

Future<Transaction>  send({required BigInt amount , required String activeMint , String? info }) => RustLib.instance.api.crateApiCashuSend(amount: amount, activeMint: activeMint, info: info);

Future<String>  requestMint({required BigInt amount , required String activeMint }) => RustLib.instance.api.crateApiCashuRequestMint(amount: amount, activeMint: activeMint);

/// this need call every init melt mint
Future<BigInt>  checkAllMintQuotes() => RustLib.instance.api.crateApiCashuCheckAllMintQuotes();

/// Checks pending proofs for spent status
Future<Map<String, BigInt>>  checkProofs() => RustLib.instance.api.crateApiCashuCheckProofs();

/// include ln and cashu
Future<Map<String, (BigInt,BigInt)>>  checkPending() => RustLib.instance.api.crateApiCashuCheckPending();

Future<Transaction>  mintToken({required BigInt amount , required String quoteId , required String activeMint }) => RustLib.instance.api.crateApiCashuMintToken(amount: amount, quoteId: quoteId, activeMint: activeMint);

Future<Transaction>  melt({required String invoice , required String activeMint , BigInt? amount }) => RustLib.instance.api.crateApiCashuMelt(invoice: invoice, activeMint: activeMint, amount: amount);

Future<List<Transaction>>  getAllTransactions() => RustLib.instance.api.crateApiCashuGetAllTransactions();

Future<List<Transaction>>  getCashuTransactionsWithOffset({required BigInt offset , required BigInt limit }) => RustLib.instance.api.crateApiCashuGetCashuTransactionsWithOffset(offset: offset, limit: limit);

Future<List<Transaction>>  getLnTransactionsWithOffset({required BigInt offset , required BigInt limit }) => RustLib.instance.api.crateApiCashuGetLnTransactionsWithOffset(offset: offset, limit: limit);

Future<List<Transaction>>  getLnPendingTransactions() => RustLib.instance.api.crateApiCashuGetLnPendingTransactions();

Future<List<Transaction>>  getCashuPendingTransactions() => RustLib.instance.api.crateApiCashuGetCashuPendingTransactions();

/// remove transaction.time() <= unix_timestamp_le and kind is the status, timestamp must be second
Future<void>  removeTransactions({required BigInt unixTimestampLe , required TransactionStatus status }) => RustLib.instance.api.crateApiCashuRemoveTransactions(unixTimestampLe: unixTimestampLe, status: status);

Future<BigInt>  getPendingTransactionsCount() => RustLib.instance.api.crateApiCashuGetPendingTransactionsCount();

Future<void>  checkTransaction({required String id }) => RustLib.instance.api.crateApiCashuCheckTransaction(id: id);

/// (spents, pendings, all)
Future<(BigInt,BigInt,BigInt)>  getAllProofsData() => RustLib.instance.api.crateApiCashuGetAllProofsData();

Future<TokenInfoV2>  decodeToken({required String encodedToken }) => RustLib.instance.api.crateApiCashuDecodeToken(encodedToken: encodedToken);

/// sleepms_after_check_a_batch for (code: 429): {"detail":"Rate limit exceeded."}
Future<BigInt>  restore({required String mintUrl , String? words }) => RustLib.instance.api.crateApiCashuRestore(mintUrl: mintUrl, words: words);

Future<InvoiceInfoV2>  decodeInvoice({required String encodedInvoice }) => RustLib.instance.api.crateApiCashuDecodeInvoice(encodedInvoice: encodedInvoice);

            
                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Amount>>
                abstract class Amount implements RustOpaqueInterface {
                    

                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MintUrl>>
                abstract class MintUrl implements RustOpaqueInterface {
                    

                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MultiMintWallet>>
                abstract class MultiMintWallet implements RustOpaqueInterface {
                    

                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< Wallet>>
                abstract class Wallet implements RustOpaqueInterface {
                    

                    
                }
                

class InvoiceInfoV2  {
                final BigInt amount;
final BigInt expiryTs;
final String hash;
final String? memo;
final String? mint;
final InvoiceStatusV2 status;

                const InvoiceInfoV2({required this.amount ,required this.expiryTs ,required this.hash ,this.memo ,this.mint ,required this.status ,});

                
                

                
        @override
        int get hashCode => amount.hashCode^expiryTs.hashCode^hash.hashCode^memo.hashCode^mint.hashCode^status.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is InvoiceInfoV2 &&
                runtimeType == other.runtimeType
                && amount == other.amount&& expiryTs == other.expiryTs&& hash == other.hash&& memo == other.memo&& mint == other.mint&& status == other.status;
        
            }

enum InvoiceStatusV2 {
                    paid,
unpaid,
expired,
                    ;
                    
                }

class TokenInfoV2  {
                final String mint;
final BigInt amount;
final CurrencyUnit? unit;
final String? memo;

                const TokenInfoV2({required this.mint ,required this.amount ,this.unit ,this.memo ,});

                
                

                
        @override
        int get hashCode => mint.hashCode^amount.hashCode^unit.hashCode^memo.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is TokenInfoV2 &&
                runtimeType == other.runtimeType
                && mint == other.mint&& amount == other.amount&& unit == other.unit&& memo == other.memo;
        
            }
            