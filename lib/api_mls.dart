// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'api_mls/types.dart';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_export_secret`, `is_admin`, `others_commit_remove_member`, `parse_welcome_message`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `MlsStore`, `RUNTIME`, `STORE`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `deref`, `deref`, `initialize`, `initialize`

Future<void> initMlsDb({required String dbPath, required String nostrId}) =>
    RustLib.instance.api.crateApiMlsInitMlsDb(dbPath: dbPath, nostrId: nostrId);

Future<String> getListenKeyFromExportSecret({required String nostrId, required String groupId}) =>
    RustLib.instance.api.crateApiMlsGetListenKeyFromExportSecret(nostrId: nostrId, groupId: groupId);

Future<Uint8List> getTreeHash({required String nostrId, required String groupId}) =>
    RustLib.instance.api.crateApiMlsGetTreeHash(nostrId: nostrId, groupId: groupId);

Future<KeyPackageResult> createKeyPackage({required String nostrId}) =>
    RustLib.instance.api.crateApiMlsCreateKeyPackage(nostrId: nostrId);

Future<BigInt> parseLifetimeFromKeyPackage({required String nostrId, required String keyPackageHex}) =>
    RustLib.instance.api.crateApiMlsParseLifetimeFromKeyPackage(nostrId: nostrId, keyPackageHex: keyPackageHex);

Future<void> deleteKeyPackage({required String nostrId, required String keyPackage}) =>
    RustLib.instance.api.crateApiMlsDeleteKeyPackage(nostrId: nostrId, keyPackage: keyPackage);

Future<Uint8List> createGroupConfig() => RustLib.instance.api.crateApiMlsCreateGroupConfig();

Future<Uint8List> getGroupConfig({required String nostrId, required String groupId}) =>
    RustLib.instance.api.crateApiMlsGetGroupConfig(nostrId: nostrId, groupId: groupId);

Future<Map<String, List<Uint8List>>> getMemberExtension({required String nostrId, required String groupId}) =>
    RustLib.instance.api.crateApiMlsGetMemberExtension(nostrId: nostrId, groupId: groupId);

Future<GroupExtensionResult> getGroupExtension({required String nostrId, required String groupId}) =>
    RustLib.instance.api.crateApiMlsGetGroupExtension(nostrId: nostrId, groupId: groupId);

Future<List<String>> getGroupMembers({required String nostrId, required String groupId}) =>
    RustLib.instance.api.crateApiMlsGetGroupMembers(nostrId: nostrId, groupId: groupId);

Future<Map<String, BigInt?>> getGroupMembersWithLifetime({required String nostrId, required String groupId}) =>
    RustLib.instance.api.crateApiMlsGetGroupMembersWithLifetime(nostrId: nostrId, groupId: groupId);

Future<Uint8List> createMlsGroup(
        {required String nostrId,
        required String groupId,
        required String groupName,
        required String description,
        required List<String> adminPubkeysHex,
        required List<String> groupRelays,
        required String status}) =>
    RustLib.instance.api.crateApiMlsCreateMlsGroup(
        nostrId: nostrId,
        groupId: groupId,
        groupName: groupName,
        description: description,
        adminPubkeysHex: adminPubkeysHex,
        groupRelays: groupRelays,
        status: status);

Future<AddMembersResult> addMembers(
        {required String nostrId, required String groupId, required List<String> keyPackages}) =>
    RustLib.instance.api.crateApiMlsAddMembers(nostrId: nostrId, groupId: groupId, keyPackages: keyPackages);

Future<MessageInType> parseMlsMsgType({required String nostrId, required String groupId, required String data}) =>
    RustLib.instance.api.crateApiMlsParseMlsMsgType(nostrId: nostrId, groupId: groupId, data: data);

Future<void> selfCommit({required String nostrId, required String groupId}) =>
    RustLib.instance.api.crateApiMlsSelfCommit(nostrId: nostrId, groupId: groupId);

Future<void> joinMlsGroup({required String nostrId, required String groupId, required List<int> welcome}) =>
    RustLib.instance.api.crateApiMlsJoinMlsGroup(nostrId: nostrId, groupId: groupId, welcome: welcome);

Future<void> deleteGroup({required String nostrId, required String groupId}) =>
    RustLib.instance.api.crateApiMlsDeleteGroup(nostrId: nostrId, groupId: groupId);

Future<CommitResult> othersCommitNormal(
        {required String nostrId, required String groupId, required String queuedMsg}) =>
    RustLib.instance.api.crateApiMlsOthersCommitNormal(nostrId: nostrId, groupId: groupId, queuedMsg: queuedMsg);

Future<MessageResult> createMessage({required String nostrId, required String groupId, required String msg}) =>
    RustLib.instance.api.crateApiMlsCreateMessage(nostrId: nostrId, groupId: groupId, msg: msg);

Future<DecryptedMessage> decryptMessage({required String nostrId, required String groupId, required String msg}) =>
    RustLib.instance.api.crateApiMlsDecryptMessage(nostrId: nostrId, groupId: groupId, msg: msg);

Future<Uint8List> getLeadNodeIndex(
        {required String nostrIdAdmin, required String nostrIdCommon, required String groupId}) =>
    RustLib.instance.api
        .crateApiMlsGetLeadNodeIndex(nostrIdAdmin: nostrIdAdmin, nostrIdCommon: nostrIdCommon, groupId: groupId);

Future<String> removeMembers({required String nostrId, required String groupId, required List<Uint8List> members}) =>
    RustLib.instance.api.crateApiMlsRemoveMembers(nostrId: nostrId, groupId: groupId, members: members);

Future<Uint8List> selfLeave({required String nostrId, required String groupId}) =>
    RustLib.instance.api.crateApiMlsSelfLeave(nostrId: nostrId, groupId: groupId);

Future<String> updateGroupContextExtensions(
        {required String nostrId,
        required String groupId,
        String? groupName,
        String? description,
        List<String>? adminPubkeysHex,
        List<String>? groupRelays,
        String? status}) =>
    RustLib.instance.api.crateApiMlsUpdateGroupContextExtensions(
        nostrId: nostrId,
        groupId: groupId,
        groupName: groupName,
        description: description,
        adminPubkeysHex: adminPubkeysHex,
        groupRelays: groupRelays,
        status: status);

Future<String> selfUpdate({required String nostrId, required String groupId, required List<int> extensions}) =>
    RustLib.instance.api.crateApiMlsSelfUpdate(nostrId: nostrId, groupId: groupId, extensions: extensions);

Future<void> othersProposalLeave({required String nostrId, required String groupId, required List<int> queuedMsg}) =>
    RustLib.instance.api.crateApiMlsOthersProposalLeave(nostrId: nostrId, groupId: groupId, queuedMsg: queuedMsg);

Future<void> adminCommitLeave({required String nostrId, required String groupId}) =>
    RustLib.instance.api.crateApiMlsAdminCommitLeave(nostrId: nostrId, groupId: groupId);

Future<Uint8List> adminProposalLeave({required String nostrId, required String groupId}) =>
    RustLib.instance.api.crateApiMlsAdminProposalLeave(nostrId: nostrId, groupId: groupId);

Future<void> normalMemberCommitLeave(
        {required String nostrId, required String groupId, required List<int> queuedMsg}) =>
    RustLib.instance.api.crateApiMlsNormalMemberCommitLeave(nostrId: nostrId, groupId: groupId, queuedMsg: queuedMsg);

Future<String?> getSender({required String nostrId, required String groupId, required String queuedMsg}) =>
    RustLib.instance.api.crateApiMlsGetSender(nostrId: nostrId, groupId: groupId, queuedMsg: queuedMsg);
