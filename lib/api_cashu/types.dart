// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';


            // These functions are ignored because they are not marked as `pub`: `get_keys`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `CashuProofsV1ToV2`, `CashuV1ToV2`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`


            

            
                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MnemonicInfo>>
                abstract class MnemonicInfo implements RustOpaqueInterface {
                    static Future<String>  generateWords({required BigInt words })=>RustLib.instance.api.crateApiCashuTypesMnemonicInfoGenerateWords(words: words);


 Future<void>  mnemonic();


  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
static Future<MnemonicInfo>  newInstance({required Mnemonic mnemonic })=>RustLib.instance.api.crateApiCashuTypesMnemonicInfoNew(mnemonic: mnemonic);


 Future<void>  pubkey();


static Future<MnemonicInfo>  withWords({required String words })=>RustLib.instance.api.crateApiCashuTypesMnemonicInfoWithWords(words: words);



                    
                }
                

class ContactCashu  {
                final String method;
final String info;

                const ContactCashu({required this.method ,required this.info ,});

                static Future<ContactCashu>  default_()=>RustLib.instance.api.crateApiCashuTypesContactCashuDefault();


                

                
        @override
        int get hashCode => method.hashCode^info.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is ContactCashu &&
                runtimeType == other.runtimeType
                && method == other.method&& info == other.info;
        
            }

class MintCashu  {
                final String url;
final bool active;
final BigInt time;
final MintCashuInfo? info;

                const MintCashu({required this.url ,required this.active ,required this.time ,this.info ,});

                
                

                
        @override
        int get hashCode => url.hashCode^active.hashCode^time.hashCode^info.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is MintCashu &&
                runtimeType == other.runtimeType
                && url == other.url&& active == other.active&& time == other.time&& info == other.info;
        
            }

class MintCashuInfo  {
                final String name;
final String version;
final String? pubkey;
final String? description;
final String? descriptionLong;
final String? motd;
final List<ContactCashu> contact;
final Map<String, bool> nuts;

                const MintCashuInfo({required this.name ,required this.version ,this.pubkey ,this.description ,this.descriptionLong ,this.motd ,required this.contact ,required this.nuts ,});

                static Future<MintCashuInfo>  default_()=>RustLib.instance.api.crateApiCashuTypesMintCashuInfoDefault();


                

                
        @override
        int get hashCode => name.hashCode^version.hashCode^pubkey.hashCode^description.hashCode^descriptionLong.hashCode^motd.hashCode^contact.hashCode^nuts.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is MintCashuInfo &&
                runtimeType == other.runtimeType
                && name == other.name&& version == other.version&& pubkey == other.pubkey&& description == other.description&& descriptionLong == other.descriptionLong&& motd == other.motd&& contact == other.contact&& nuts == other.nuts;
        
            }

class SendStampsResult  {
                final Transaction tx;
final bool isNeedSplit;

                const SendStampsResult({required this.tx ,required this.isNeedSplit ,});

                
                

                
        @override
        int get hashCode => tx.hashCode^isNeedSplit.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is SendStampsResult &&
                runtimeType == other.runtimeType
                && tx == other.tx&& isNeedSplit == other.isNeedSplit;
        
            }

class Transaction  {
                final String id;
final String mintUrl;
final TransactionDirection io;
final TransactionKind kind;
final BigInt amount;
final BigInt fee;
final String? unit;
final String token;
final TransactionStatus status;
final BigInt timestamp;
final Map<String, String> metadata;

                const Transaction({required this.id ,required this.mintUrl ,required this.io ,required this.kind ,required this.amount ,required this.fee ,this.unit ,required this.token ,required this.status ,required this.timestamp ,required this.metadata ,});

                
                

                
        @override
        int get hashCode => id.hashCode^mintUrl.hashCode^io.hashCode^kind.hashCode^amount.hashCode^fee.hashCode^unit.hashCode^token.hashCode^status.hashCode^timestamp.hashCode^metadata.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is Transaction &&
                runtimeType == other.runtimeType
                && id == other.id&& mintUrl == other.mintUrl&& io == other.io&& kind == other.kind&& amount == other.amount&& fee == other.fee&& unit == other.unit&& token == other.token&& status == other.status&& timestamp == other.timestamp&& metadata == other.metadata;
        
            }

enum TransactionDirection {
                    incoming,
outgoing,
split,
                    ;
                    
                }

enum TransactionKind {
                    cashu,
ln,
                    ;
                    
                }

enum TransactionStatus {
                    pending,
success,
failed,
expired,
                    ;
                    
                }
            