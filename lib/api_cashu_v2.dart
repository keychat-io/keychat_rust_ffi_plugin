// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'api_cashu_v2/types.dart';
import 'frb_generated.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';


            // These functions are ignored because they are not marked as `pub`: `_send`, `check_sufficient_funds`, `get_or_create_wallet`, `get_wallet_by_mint_url`, `mint_balances`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `deref`, `fmt`, `fmt`, `fmt`, `initialize`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `get_mnemonic_info`, `get_wallet`, `mnemonic`, `update_mnmonic`


            Future<void>  initDb({required String dbpath , required String words , required bool dev }) => RustLib.instance.api.crateApiCashuV2InitDb(dbpath: dbpath, words: words, dev: dev);

Future<Map<String, void>>  initCashu({required int prepareSatsOnceTime }) => RustLib.instance.api.crateApiCashuV2InitCashu(prepareSatsOnceTime: prepareSatsOnceTime);

Future<bool>  setMnemonic({String? words }) => RustLib.instance.api.crateApiCashuV2SetMnemonic(words: words);

Future<Map<String, void>>  getMints() => RustLib.instance.api.crateApiCashuV2GetMints();

Future<void>  addMint({required String url }) => RustLib.instance.api.crateApiCashuV2AddMint(url: url);

Future<void>  removeMint({required String url }) => RustLib.instance.api.crateApiCashuV2RemoveMint(url: url);

Future<String>  getBalances() => RustLib.instance.api.crateApiCashuV2GetBalances();

Future<TransactionV2>  sendAll({required String mint }) => RustLib.instance.api.crateApiCashuV2SendAll(mint: mint);

/// default set 20
Future<void>  mergeProofs({required BigInt thershold }) => RustLib.instance.api.crateApiCashuV2MergeProofs(thershold: thershold);

/// inner used, this is for receive stamps every multi times
Future<void>  multiReceive({required List<String> stamps }) => RustLib.instance.api.crateApiCashuV2MultiReceive(stamps: stamps);

Future<TransactionV2>  receiveToken({required String encodedToken }) => RustLib.instance.api.crateApiCashuV2ReceiveToken(encodedToken: encodedToken);

/// inner used
Future<void>  printProofs({required String mint }) => RustLib.instance.api.crateApiCashuV2PrintProofs(mint: mint);

Future<BigInt>  prepareOneProofs({required BigInt amount , required String mint }) => RustLib.instance.api.crateApiCashuV2PrepareOneProofs(amount: amount, mint: mint);

Future<TransactionV2>  sendStamp({required BigInt amount , required List<String> mints , String? info }) => RustLib.instance.api.crateApiCashuV2SendStamp(amount: amount, mints: mints, info: info);

/// Helper function to get a wallet from the multi-mint wallet
Future<Wallet>  getWalletByIndex({required MultiMintWallet multiMintWallet , required List<(MintUrl,Amount)> mintAmounts , required BigInt mintNumber , required CurrencyUnit unit }) => RustLib.instance.api.crateApiCashuV2GetWalletByIndex(multiMintWallet: multiMintWallet, mintAmounts: mintAmounts, mintNumber: mintNumber, unit: unit);

/// Helper function to validate a mint number against available mints
Future<void>  validateMintNumber({required BigInt mintNumber , required BigInt mintCount }) => RustLib.instance.api.crateApiCashuV2ValidateMintNumber(mintNumber: mintNumber, mintCount: mintCount);

Future<TransactionV2>  send({required BigInt amount , required String activeMint , String? info }) => RustLib.instance.api.crateApiCashuV2Send(amount: amount, activeMint: activeMint, info: info);

Future<String>  requestMint({required BigInt amount , required String activeMint }) => RustLib.instance.api.crateApiCashuV2RequestMint(amount: amount, activeMint: activeMint);

/// this need call every init melt mint
Future<BigInt>  checkAllMintQuotes() => RustLib.instance.api.crateApiCashuV2CheckAllMintQuotes();

/// Checks pending proofs for spent status
Future<BigInt>  checkAllPendingProofs({required String activeMint }) => RustLib.instance.api.crateApiCashuV2CheckAllPendingProofs(activeMint: activeMint);

Future<TransactionV2>  mintToken({required BigInt amount , required String quoteId , required String activeMint }) => RustLib.instance.api.crateApiCashuV2MintToken(amount: amount, quoteId: quoteId, activeMint: activeMint);

Future<TransactionV2>  melt({required String invoice , required String activeMint , BigInt? amount }) => RustLib.instance.api.crateApiCashuV2Melt(invoice: invoice, activeMint: activeMint, amount: amount);

Future<List<TransactionV2>>  getAllTransactions() => RustLib.instance.api.crateApiCashuV2GetAllTransactions();

Future<List<TransactionV2>>  getCashuTransactionsWithOffset({required BigInt offset , required BigInt limit }) => RustLib.instance.api.crateApiCashuV2GetCashuTransactionsWithOffset(offset: offset, limit: limit);

Future<List<TransactionV2>>  getLnTransactionsWithOffset({required BigInt offset , required BigInt limit }) => RustLib.instance.api.crateApiCashuV2GetLnTransactionsWithOffset(offset: offset, limit: limit);

Future<List<TransactionV2>>  getLnPendingTransactions() => RustLib.instance.api.crateApiCashuV2GetLnPendingTransactions();

Future<List<TransactionV2>>  getCashuPendingTransactions() => RustLib.instance.api.crateApiCashuV2GetCashuPendingTransactions();

/// remove transaction.time() <= unix_timestamp_le and kind is the status, timestamp must be second
Future<void>  removeTransactions({required BigInt unixTimestampLe , required TransactionStatusV2 status }) => RustLib.instance.api.crateApiCashuV2RemoveTransactions(unixTimestampLe: unixTimestampLe, status: status);

Future<BigInt>  getPendingTransactionsCount() => RustLib.instance.api.crateApiCashuV2GetPendingTransactionsCount();

/// include ln and cashu
Future<void>  checkPending() => RustLib.instance.api.crateApiCashuV2CheckPending();

Future<void>  checkTransaction({required String id }) => RustLib.instance.api.crateApiCashuV2CheckTransaction(id: id);

/// (spents, pendings, all)
Future<(BigInt,BigInt,BigInt)>  checkProofs() => RustLib.instance.api.crateApiCashuV2CheckProofs();

Future<TokenInfoV2>  decodeToken({required String encodedToken }) => RustLib.instance.api.crateApiCashuV2DecodeToken(encodedToken: encodedToken);

/// sleepms_after_check_a_batch for (code: 429): {"detail":"Rate limit exceeded."}
Future<BigInt>  restore({required String mintUrl , String? words }) => RustLib.instance.api.crateApiCashuV2Restore(mintUrl: mintUrl, words: words);

Future<InvoiceInfoV2>  decodeInvoice({required String encodedInvoice }) => RustLib.instance.api.crateApiCashuV2DecodeInvoice(encodedInvoice: encodedInvoice);

            
                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Amount>>
                abstract class Amount implements RustOpaqueInterface {
                    

                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MintUrl>>
                abstract class MintUrl implements RustOpaqueInterface {
                    

                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MultiMintWallet>>
                abstract class MultiMintWallet implements RustOpaqueInterface {
                    

                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TransactionStatusV2>>
                abstract class TransactionStatusV2 implements RustOpaqueInterface {
                    

                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< Wallet>>
                abstract class Wallet implements RustOpaqueInterface {
                    

                    
                }
                

class InvoiceInfoV2  {
                final BigInt amount;
final BigInt expiryTs;
final String hash;
final String? memo;
final String? mint;
final InvoiceStatusV2 status;

                const InvoiceInfoV2({required this.amount ,required this.expiryTs ,required this.hash ,this.memo ,this.mint ,required this.status ,});

                
                

                
        @override
        int get hashCode => amount.hashCode^expiryTs.hashCode^hash.hashCode^memo.hashCode^mint.hashCode^status.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is InvoiceInfoV2 &&
                runtimeType == other.runtimeType
                && amount == other.amount&& expiryTs == other.expiryTs&& hash == other.hash&& memo == other.memo&& mint == other.mint&& status == other.status;
        
            }

enum InvoiceStatusV2 {
                    paid,
unpaid,
expired,
                    ;
                    
                }

class TokenInfoV2  {
                final String mint;
final BigInt amount;
final CurrencyUnit? unit;
final String? memo;

                const TokenInfoV2({required this.mint ,required this.amount ,this.unit ,this.memo ,});

                
                

                
        @override
        int get hashCode => mint.hashCode^amount.hashCode^unit.hashCode^memo.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is TokenInfoV2 &&
                runtimeType == other.runtimeType
                && mint == other.mint&& amount == other.amount&& unit == other.unit&& memo == other.memo;
        
            }
            