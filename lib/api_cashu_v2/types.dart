// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';


            // These functions are ignored because they are not marked as `pub`: `get_keys`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`


            

            
                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MnemonicInfo>>
                abstract class MnemonicInfo implements RustOpaqueInterface {
                    static Future<String>  generateWords({required BigInt words })=>RustLib.instance.api.crateApiCashuV2TypesMnemonicInfoGenerateWords(words: words);


 Future<void>  mnemonic();


  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
static Future<MnemonicInfo>  newInstance({required Mnemonic mnemonic })=>RustLib.instance.api.crateApiCashuV2TypesMnemonicInfoNew(mnemonic: mnemonic);


 Future<void>  pubkey();


static Future<MnemonicInfo>  withWords({required String words })=>RustLib.instance.api.crateApiCashuV2TypesMnemonicInfoWithWords(words: words);



                    
                }
                

enum TransactionDirectionV2 {
                    incoming,
outgoing,
split,
                    ;
                    
                }

enum TransactionKindV2 {
                    cashu,
ln,
                    ;
                    
                }

class TransactionV2  {
                final String mintUrl;
final TransactionDirectionV2 direction;
final TransactionKindV2 kind;
final BigInt amount;
final BigInt fee;
final String? unit;
final String token;
final BigInt timestamp;
final Map<String, String> metadata;

                const TransactionV2({required this.mintUrl ,required this.direction ,required this.kind ,required this.amount ,required this.fee ,this.unit ,required this.token ,required this.timestamp ,required this.metadata ,});

                
                

                
        @override
        int get hashCode => mintUrl.hashCode^direction.hashCode^kind.hashCode^amount.hashCode^fee.hashCode^unit.hashCode^token.hashCode^timestamp.hashCode^metadata.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is TransactionV2 &&
                runtimeType == other.runtimeType
                && mintUrl == other.mintUrl&& direction == other.direction&& kind == other.kind&& amount == other.amount&& fee == other.fee&& unit == other.unit&& token == other.token&& timestamp == other.timestamp&& metadata == other.metadata;
        
            }
            